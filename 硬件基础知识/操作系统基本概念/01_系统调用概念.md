---
title: 01_系统调用概念
tags: 
---

“操作系统”通常包含以下两种含义：

1. 表示完整的软件包，包括用来管理计算机资源的核心层软件，以及附带的所有标准软件工具，诸如命令行解释器. 图形用户界面. 文件操作工具和文本编辑器等；
2. 狭义上的操作系统是指管理和分配计算机资源（如CPU. RAM和设备）的核心层软件。

内核负责管理分配计算机资源，作为计算机和用户之间的沟通桥梁而存在。因此就有内核态和用户态的概念。执行硬件指令可以在两种状态间转换。与之对应，可以将虚拟内存分为内核空间和用户空间。在用户态运行时，CPU只能访问用户空间；在内核态运行时，CPU可以访问内核空间和用户空间。

系统调用是受控的内核入口，借助这一机制，进程可以请求内核以自己的名义去执行某些动作。以应用程序编程接口的形式（API），内核提供了一系列服务。这些服务包括创建新锦程. 执行I/O. 为进程间通信创建管道等。

需要注意：

- 系统调用将处理器从用户态切换到内核态，以便CPU访问受保护的内核空间；
- 系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识；
- 每个系统调用都提供一套参数，来规范用户空间与内核空间之间的信息传递；

从编程角度来看，系统调用很像C语言函数调用。下面是一个系统调用事件的发生顺序：

1. 应用程序通过调用C语言的外壳函数（wrapper）发起系统调用；
2. 对系统调用中断处理例程来说，外壳函数必须保证所有的系统调用参数可用。参数是通过堆栈传递到外壳函数的，但内核希望这些参数置入特定的寄存器。因此，外壳函数将上述参数复制到寄存器；
3. 由于所有的系统调用进入内核的方式相同，内核需要设法区分每个系统调用。因此外壳函数会将系统调用编号复制到一个特殊的CPU寄存器中；
4. 外壳函数执行一条中断机器指令（int 0x80），引发处理器从用户态切换到内核态，并执行系统中断0x80的中断矢量所指向的代码；
5. 为响应0x80中断，内核会调用system_call()例程，来处理中断，具体如下：
	- 在内核栈中保存寄存器值；
	- 审核系统调用编号的有效性；
	- 以系统调用编号对存放所有调用服务例程的列表（内核变量sys_call_table）进行索引，发现并调用相应的系统调用服务例程。若系统调用服务例程带有参数，那么将首先检查参数的有效性。随后该服务例程会执行必要的任务，这可能会涉及对特定参数中指定地址处的值进行修改，以及在用户内存和内核内存间传递数据。最后该服务例程会将结果状态返回给system_call()例程；
	- 从内核态回复寄存器的值，并将系统调用返回值置于堆栈中；
	- 返回外壳函数，同时将处理器切换到用户态；
6. 若系统调用服务例程的返回值表明调用出错，外壳函数会使用该值来设置全局变量errno。然后外壳函数会返回调用函数，并返回一个整数型值，以表明系统调用是否成功。

下图以系统调用execve()为例，展示了上述事件的发生序列：

![](https://raw.githubusercontent.com/OliverRen/olili_blog_img/master/01_系统调用概念/20201122/1606047093406.png)

参考 [Ezioooooo的cnBlog](https://blog.csdn.net/u012877472/article/details/49907137)