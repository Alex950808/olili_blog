---
title: 09_指令集架构MIPS_x86_arm
tags: 
---

#### 渊源

MIPS,x86架构和arm架构并不是CPU底层实现的硬件规范而是CPU对外提供服务的指令集

当今处理器一共有三个最强大的架构

- 其中之一是以intel和AMD为代表的x86架构
- 另外一个是手机，平板处理器所使用的ARM架构
- 最后一个便是我国龙芯处理器所选择的MIPS架构。

这三大处理器架构中，x86和ARM是商业化进程最为优秀的两大架构。也正是因为这两大架构的商业化进程太为出色，所以我国的龙芯处理器才被很多人批判为最严重的选择性失误。龙芯处理器的架构选择并没有错误，相反的如果龙芯要想得到更好的发展，选择MIPS才是最为正确的道路。

x86架构的拥有者intel可以算作是技术合作上最抠门儿的一位，在推出x86架构之后，intel就只将这一架构授权给过AMD和VIA等几个芯片公司。而在VIA退出x86架构处理器竞争之后，intel便不再给任何公司x86架构授权。所以从x86架构上入手，龙芯处理器显然是行不通的。 

intel的x86架构行不通，那么ARM架构是否就能行得通呢？答案当然也是否定的。

ARM公司是一家非常优秀的芯片设计公司，但自身并不生产处理器，而是将自身的设计licensing卖给需要处理器的公司,而后交给他们生产或者是找人代工。也许有人要问了，既然ARM向外卖出架构设计，那么为何龙芯不去选择ARM架构呢？其实不然，ARM之所以能够发展成为一家非常成功的商业性公司，靠的就是芯片的架构设计，倘若架构设计被别人夺走了，那么自己就丢掉了赖以生存的饭碗。所以ARM虽然对外进行licensing授权，却不允许购买者进行任何对ARM架构有更改的设计。倘若个更改了设计，那么这便违反了合作协定,ARM便有权撤回licensing授权。我国的龙芯要是选择了ARM架构的话，那么基本上也就被捆住了脚步，无法发展出属于自己的高性能处理器了。
 
考虑到市场发展的问题ARM也对外妥协过。目前高通，苹果和NVIDIA这三家公司便是ARM体系中较为特殊的几个。因为这三家公司在芯片设计领域的特殊地位，ARM为了能够拉拢他们站立在自己的阵营中，对这三家公司开出了特别通行证。在其他芯片公司只能使用 licensing去生产芯片的时候，高通，苹果和NVIDIA却能够自行设计基于ARM架构的处理器。也正是拉拢到了高通，苹果和NVIDIA，才使得ARM拥有了更多的支持者。但即便这样，我们也不得不佩服ARM的老狐狸作风，在给出架构授权后，ARM依然会通过升级下一代架构为由让高通，苹果和 NVIDIA再掏一回钱购买架构授权。这样ARM就可以再赚一把。相信看到这里您应该了解到龙芯不选择ARM的原因了。

MIPS和ARM虽然都是对外进行架构授权的公司，但意义完全不同。ARM对外出售的是设计方案授权 （licensing），与ARM的商业化相比，MIPS倒像是学院派的公司。MIPS的架构授权，并不限制任何对MIPS架构的更改。换句话说，就是 MIPS公司给授权者一张白纸，而白纸上仅仅写着一行字，MIPS公司同意你设计生产MIPS架构处理器，至于你设计成什么样，性能有多高，经过多少代更改，MIPS一概不管，只要你不把架构彻底改变就行了。与ARM相比，MIPS是一个完全开放的架构，对龙芯未来的发展没有任何的限制，这与intel给 AMD x86架构授权，而不是给设计图纸的道理是完全一样的。在加上MIPS本身经过几十年的发展，已经拥有了众多的应用软件，综合考虑来看，MIPS是最为适合龙芯处理器发展的架构选择。RISC平台是诞生于MIPS早先产品的，也正是RISC平台的诞生，才最终发展成为了我们现在的智能手机与平板机这样强大的产品。然而作为RISC系统的创始人，MIPS的商业化发展并非一帆风顺，也许是受公司前身是大学科学实验室的影响。公司高层对商业化发展嗤之以鼻， 这才令本身技术要落后于MIPS的ARM得到了发展时机。

参考自 [afiych的cnBlog](https://blog.csdn.net/afiych/article/details/72036972)

#### 产生不同指令集的故事

上世纪70年代末期，计算机的出现虽然带来了各种方便，但也带来了各种不方便。首先就是编程。当时没有类似今天这样的高级的、接近自然语言的、各种逻辑都非常完善的编程语言，而是采用最底层的机器语言来写命令。

机器语言和后来的汇编语言，在使用中都显得很麻烦，可读性差，并且很难维护。此外，还有最重要的一点是，这些语言都比较“笨”，如果要计算一些稍微复杂的操作比如乘法、除法、三角函数、微积分、方程等，每次计算都需要重新编写程序（在纸带上打孔输入数据的时代，是没有“粘贴+复制”的方便功能的）。

于是人们想了一个方法，对一些比较常用的指令，比如积分、微分、乘除法等，干脆写一套标准的程序，留下输入数据的接口。这样就能够大幅度地降低编程中的难度，提高编程效率并增加其易用性。这个想法一提出，就得到了很多业内人士的认可，大家给这种想法取了一个名字，叫做“指令集”。

指令集中包含了大量的基础运算的内容，并且以公式化和模块化的方式供人们使用。对软件来说，指令集的出现无疑大幅度提高了程序编写的效率。同时由于模块化指令的存在，软件的运行效率也得到了提升。对硬件来说，专用模块的效率永远高于通用模块，因此指令集的出现也为CPU硬件性能的提升开启了一扇新的大门。

指令集诞生后，CPU厂商都开始整理、规范这些指令集，其中就包括英特尔。英特尔在它最为成功的一款处理器8086中，开始加入大量指令集，以提高计算效率、增强CPU性能。与此同时，另外一种思想在悄悄萌芽。

业界有一个著名的“8020定理”，可以应用在很多方面：比如一家公司80%的人都会是普通职员，20%的人才可能成为领导者；这些领导者每天做的事情80%是不紧急或者不重要的、20%才是最紧急最重要的内容等等。“8020定理”概括了社会发展的大部分内容，虽然不那么精确，但足以说明大部分内容往往没有什么效率，最值得关心的往往是那20%的核心部分—比如下面这一段：

CPU的指令集是各种功能的集合。指令集诞生的原因是人们渴望在软件编写时更有效率，同时也符合事物发展中规范化、模块化的需求。但是，在所有指令集中，经过人们分析和统计，只有20%的指令集会在80%的场合都用到，而绝大部分80%的指令集只有20%的场合需要出现。

这里的意思就很明确了。如果一个CPU支持所有的指令集，那么其中20%的部分会被经常调用，而80%的部分经常闲置无所事事，至少在80%的时间中都是如此。在CPU晶体管“寸土寸金”的年代，这样的做法是对晶体管的严重浪费。在这种情况下，曾任斯坦福大学校长、美国科学院、工程学院和文理学院三院院士的约翰·亨尼西教授和加州大学伯克利分校的计算机教授戴维·帕特森等人，就提出了一种更为简单的指令集，叫做精简指令集，全称是Reduced Instruction Set Computing，简写为RISC。而传统的大而全的指令集也被赋予了一个正式的名字，叫做Complex Instruction Set Computing，也就是CISC。

RISC的优势在于将指令数目和寻址方式都做出了改进，大幅度降低了设计难度，编译器的效率更高并且指令的并行执行程度更高。同时RISC制造的CPU体积更小、能耗更低、性能功耗比更高。但是RISC并不是没有缺点，比如RISC的CPU对20%的常用指令集的计算效率更高，而对一些不常用或者复杂的指令，则以几个常用指令组合的方式来完成，计算效率就明显下降。对软件来说，RISC的程序体积相对CISC会大一些，复杂度稍高。并且由于指令集精简，早期的RISC处理器的性能显然不如同期的CISC，虽然它更小、功耗更低。

虽然从原理来看，RISC和CISC可谓井水不犯河水。但RISC和CISC在发展过程中，彼此反而取长补短，各有所得。

对CISC来说，指令集本身随着计算要求不断发展，肯定会越来越多。CISC继续发展下去，其实际CPU产品的晶体管数量会难以抑制地上升，性能功耗比和成本表现很难让人满意。从设计角度来看，CISC指令集长度不固定、执行时间也不固定、设计困难很多，很难找出一条高效率的通用设计道路来完成指令的执行。此外，由于CISC处理器和存储器之间的速度差距，缓存变得越来越重要。这也意味着CPU本身需要更为精简高效，节省的空间需要用于容纳越来越重要的各级缓存。

为了解决这些问题，现代的CISC处理器开始认真学习RISC的思想。CISC的问题在于指令集复杂多变，为每一个指令制定专门的硬件优化显然不可能。那么，可不可以换一个思路呢？将那些最常使用的指令集挑选出来，然后为其进行专门优化，就可以大大提高效率；至于不常用的指令，则可以用几个基础指令组合的方式完成——这正是RISC的思想。有所不同的是，RISC让思想完成在指令层面，而CISC将这个思想实现在硬件层面。

参考 [奋进的苦瓜的cnBlog](https://www.cnblogs.com/bitter/p/4023176.html)

#### 技术差异 
 
寄存器，输入输出模型规范，CPU指令就是具体的机器码，机器语言，寄存器规范指的是寄存器的种类，个数和状态，输入输出模型是CPU引脚的输入输出规范，具体的CPU指令和寄存器使用可以参考对应架构的汇编语言。

x86指令集是CISC(Complex Instruction Set Computers，复杂指令集计算集)的代表，主要应用于PC，服务器和大型机等处理器

arm指令集是RISC(Reduced Instruction Set Computers，精简指令集计算集)的代表，主要应用于移动端和嵌入式等处理器。

两者的设计思想是相反的，CISC是由CPU提供复杂功能的指令从而降低其上层程序开发的难度，提升复杂逻辑下系统性能，问题是复杂指令的实现增加了CPU整体的设计难度并影响执行效率，而RISC则是由CPU提供最常用的简单的指令，复杂指令由编译器将其拆分成多个简单指令实现，这样降低了CPU的设计难度，提升了常用指令的执行效率，但是增加了上层程序的复杂性，降低了复杂逻辑下系统效率。现代CISC处理器和RISC处理器在发展的过程中彼此取长补短，逐步走向融合。

指令集本身也是在不断发展的，通过不断追加新的指令实现，之前的指令保持不变，从而保持向前兼容。指令集架构的32-bit或64-bit决定了对应处理器的位数，处理器的位数决定了与处理器配套的地址总线，数据总线的位宽，现代CPU通常都是64位的，linux上可通过lscpu命令查看。