---
title: 哥伦比亚大学区块链教程
tags: 小书匠语法,技术
renderNumberedHeading: true
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---

[toc]

### 讲义1. 区块链和密码学简介

讲义1 为你介绍区块链和密码学
李崇

**概要**

*   ==管理 #F44336==
*   密码学和区块链的介绍
*   加密hash函数
*   椭圆曲线的数字签名

管理

*   讲师:李崇 张磊
*   email: [cl3607@columbia.edu](mailto:cl3607@columbia.edu)
*   email: [lz2671@columbia.edu](mailto:lz2671@columbia.edu)
*   工作时间:按照规定
*   TA/CA:待定

评分

*   5个双周作业:每次10%
*   期中期末考试:期中20%,期末30%

参考文献和知识准备参考文献

*   Narayanan, Arvind等人所著的 比特币和加密货币技术:全面介绍。普林斯顿大学大学出版社,2016年。(pdf在线可用)
*   学术论文和其他区块链项目的白皮书

知识准备

*   基本的统计和概率论知识 期望，方差，分布等
*   基本的编程能力
*   激情和兴趣

------

**概要**

*   管理
*   ==密码学和区块链的介绍 #F44336==
*   加密hash函数
*   椭圆曲线的数字签名

**什么是比特币？**

*   第一个并且是醉广泛使用的加密数字货币
*   完全数字化,去中心化,使用密码学,计算机和经济学理论设计的货币
*   谁是中本聪
*   白皮书: 比特币:一个点对点网络电子货币系统 2008
*   译者注 [比特币通俗理解文字说明](http://www.8btc.com/bitcoin-story)
*   译者注 [比特币基本概念](http://www.8btc.com/wiki/bitcoin-basic-concepts)
*   译者注 [But how does bitcoin actually work?](https://www.youtube.com/watch?v=bBC-nXj3Ng4)

**比特币的价格**
比特币的泡沫破裂有利于整个区块链行业
![](qiniu.imolili.com/小书匠/1592215436378.png)

**比特币与银行**
![](qiniu.imolili.com/小书匠/1592215449145.png)

将个人信息和银行账户连接起来并验证所有权
转账和存取款
跟踪和更新账户的余额
根据政府规定由专业人士提供服务

![](qiniu.imolili.com/小书匠/1592215456506.png)

给与用户自主的创建和管理id
在点对点网络中发送资产
在区块链中每个节点都保存和更新同一份总账
根据可信的协议来激励参与者诚信行事

**比特币和区块链**

*   一个去中心化的网络通常面对如下两个问题

*   每个节点中的信息不一致(由于网络通信的延迟)
*   难以解决恶意节点的攻击(由于随机的公共访问)

*   我们怎么才能建立一个分布式的网络来解决上述问题?
*   解决方案:区块链技术
*   比特币,一种数字货币,就是第一个这种网络中的成功应用.

------

**概要**

*   管理
*   密码学和区块链的介绍
*   ==加密hash函数 #F44336==
*   椭圆曲线的数字签名

**加密散列函数**

*   y=h(x)
*   把任意长度的字符串作为输入,并产生一个固定长度的字符串作为输出
*   需要满足如下三个特性
	*   抗原像性(译者注:单向性)
	*   强抗碰撞性
	*   抗第二原像性(弱抗碰撞性)
译者注:其实2,3换下位置更好

抗原像性
单向性,如果由hash值,应该非常困难找到原文
任意y,找x,使得 f(x)=y 非常困难

强抗碰撞性
*   不可能找到两个不同的值以满足 h(x1)=h(x2)
*   冲突确实是存在的,为什么呢? 那么为什么说找到满足条件的值是不可行的
*   生日攻击法

生日悖论(生日攻击法)
定理: !1,!2,!3...!n 属于{1,2,3,4...,\*} 独立同分布的整数,则
![](qiniu.imolili.com/小书匠/1592215488428.png)

在白板进行证明 提示:伯努利不等式 自然对数的x次方大于等于 1+ x

举例(译者注):在23个人中,存在两个生日在同一天的人的概率为0.5073,如果增加人数到30个人,则这个概率大概由0.7,进而如果有100个人,则这个概率能达到0.9999997,利用这个原理,攻击者只需要枚举一定量的值,就可以找出一堆hash值相同的输入值

强抗碰撞性
在2015年的一月,比特币的矿工们就可以每秒计算 300\*10的15次方hash计算
如果使用的是sha-256,则一次强碰撞需要 
![](qiniu.imolili.com/小书匠/1592215501913.png)
而我们宇宙的年龄也只有 13.7\*10的9次方年

抗第二原像性
*   对于给定x计算出来的hash值,应该很难找到另一个x1达成 h(x)=h(x1)
*   要找到相同的第二原像 x1 需要 0(2的n次方)的时间复杂度

安全的hash算法 SHA-256
*   SHA是被NIST开发的
*   SHA-256是指输出的hash长度有256个bit

![](qiniu.imolili.com/小书匠/1592215519683.png)

--------

**概要**

*   管理
*   密码学和区块链的介绍
*   加密hash函数
*   ==椭圆曲线的数字签名 #F44336==

**电子签名**

*   是公匙密码学的一个重要概念 译者注: https://zh.wikipedia.org/wiki/公开密匙加密
*   在Diffie和Hellman于1976的论文中被提出
*   方案
	1.Alice想发送消息给Bob
	2.爱丽丝首先生成密钥对（SK，PK）与给定的密钥长度
	3.鲍勃只需要知道PK。
	4.Alice产生签名=符号（SK，消息）
	5.鲍勃通过检查验证消息（PK，消息，签名）\*（SK，PK）=（秘密/私有密钥，公共密钥）
	
**数字签名实践**

签名
![](qiniu.imolili.com/小书匠/1592215534254.png)

校验

![](qiniu.imolili.com/小书匠/1592215542673.png)

**比特币中的ECDSA**
译者注: [数字签名:ECDSA](https://blog.csdn.net/qq_31301681/article/details/77937103)
译者注: [ECDH 和 ECDSA](https://blog.csdn.net/mrpre/article/details/72850644) ECDH它实际上是密钥协商算法，而不是加解密算法。 
译者注: [椭圆曲线算法 ECC](http://www.freebuf.com/articles/database/155912.html)
译者注: [ECDSA定义的集合行为简介](https://www.8btc.com/article/63058)
译者注: [ECDSA说明](https://www.8btc.com/article/34080)

*   ECDSA 全称 椭圆曲线数字签名算法
*   一种在群论基础上建立的技术

译者注: [在数学和抽象代数中,群论研究名为群的代数结构](https://zh.wikipedia.org/wiki/群论)

![](qiniu.imolili.com/小书匠/1592274024685.png)

译者注:比特币地址的生成和校验步骤比特币地址的结构比特币地址和私钥是由ECDSA椭圆曲线加密算法计算出来的，由ECDSA私钥计算出我们常用的Bitcoin-qt格式比特币地址需要有十个步骤。

* 第一步，产生ECDSA私钥，如：
18E14A7B6A307F426A94F8114701E7C8E774E7F9A47E2C2035DB29A206321725

* 第二步，计算出ECDSA公钥
0450863AD64A87AE8A2FE8….82BA6

* 第三步，对公钥进行SHA256运算600FFE422B4E00731A59557A5CCA46CC183944191006324A447BDB2D98D4B408

* 第四步，对第三步结果进行RIPEMD-160运算010966776006953D5567439E5E39F86A0D273BEE

* 第五步，在第四步结果上加上版本号
00010966776006953D5567439E5E39F86A0D273BEE

* 第六步，对第五步结果进行SHA256运445C7A8007A93D8733188288BB320A8FE2DEBD2AE1B47F0F50BC10BAE845C094

* 第七步，对第六步结果进行SHA256运算D61967F63C7DD183914A4AE452C9F6AD5D462CE3D277798075B107615C1A8A30

* 第八步，提出第七步结果的前四个字节
D61967F6

* 第九步，将第八步的结果加到第五步结果最后面00010966776006953D5567439E5E39F86A0D273BEED61967F6

* 第十步，对第九步结果进行Base58编码
16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM

我们由上面的十个步骤可以看出。第八步中的四个字节是拿出来做checksum检查的。检查一个地址是否有效，我们只需要将第十步的结果做逆运算，去掉最后四个字节得到第四步的结果，然后做两次SHA256运算看看能否重新计算出的结果是否以这四个字节开头就行了。

![](qiniu.imolili.com/小书匠/1592274042216.png)

**群**

*   一般来说,群是指包含某一种运算和其中任意a,b得出的c的并且满足以下四个条件的集合G.封闭性,结合律成立,单位元存在,逆元存在.
*   举例:整数 0-9 和运算 %10
*   属性
	*   封闭性,任意两个数相加 %10都是在0-9之中
	*   单位元存在: 0对于任意整数来说都满足 a*e = e*a = a
	*   逆元存在: 10-a 对于集合中任意a来说运算结果都是 10-a,即 a*b=b*a=b,所以 10-a即为 a的逆元
	*   结合率成立 对于任意a,b,c \in G,a+(b+c) = (a+b)+c成立

译者注:
严谨的表述群的定义及其概念
![](qiniu.imolili.com/小书匠/1592274068208.png)

1.群的定义是很容易理解的，关键点是封闭性，结合律，单位元，逆元。
2.群元素的数目叫做群的阶
3.理解群的最基本的出发点的是群的乘法表

写群乘法表的关键是重排定理，即乘法表每一行每一列所有元素都要出现且只出现一次。有了这个定理，就可以很快确定乘法表

**椭圆曲线**
椭圆曲线方程 
![](qiniu.imolili.com/小书匠/1592274072343.png)
ECDSA中选择的参数是
![](qiniu.imolili.com/小书匠/1592274081729.png)
一些示例
![](qiniu.imolili.com/小书匠/1592274085984.png)
几何中的加法定义
![](qiniu.imolili.com/小书匠/1592274077612.png)
*图取自Vitalik Buterin的“探索椭圆曲线配对”*

为了更好的理解,下面大段的译者注
>椭圆曲线有一些很有用的特征。例如，一条非垂直的直线与椭圆曲线相交于两点，若这两点均不是切点，则曲线上必有第三点与那条直线相交。另一个特征是，过曲线上任意一点的非垂直切线与该曲线必有且仅有另一个交点。
利用这些特征，我们可以定义两种运算：“异点相加”和“同点加倍”。用弦切法规则来定义加法运算“异点相加”, P + Q = R, 定义为：R为R’基于x轴的反射点（对称点）。其中，R’为包含P和Q的直线与曲线的第三个交点。
"同点加倍”，P + P = R, 定义为：作一条过P点的切线，先求出该切线与曲线的另一交点R’,再计算R‘基于x轴的反射点R。
将这两种运算结合起来可以用于标量乘法，R = a P, 定义为将P点与其自身相加a次。例如：R = 7P => R = P + (P + (P + (P + (P + (P + P)))))
标量乘法的运算过程可以通过“异点相加”与“同点加倍”运算相结合来简化。例如：
R = 7P
R = P + 6P
R = P + 2 (3P)
R = P + 2 (P + 2P)
这里，7P被分解为两步“同点加倍”和两步“异点相加”。

译者注:上面在几何中定义的运算在实际运算中,还需要把几何方法转化为代数方法,这实际上是非常繁琐的，因为需要求解三次方程.这里只写结果
![](qiniu.imolili.com/小书匠/1592274247734.png)

译者注:所谓的椭圆曲线是指一个齐次方程.数与形的结合所确定的平面曲线.
一个无穷远点的特殊点和椭圆上的所有点构成一个集合,连同一个定义的加法运算构成一个Abel群,ECDSA中更详细的资料可以参看上文中 比特币中的ECDSA 一节引用的外部文档.

译者注:比特币网络中使用的椭圆曲线方程参数是 a=0,b=7, 这一特定的实现被命名为 secp256k1
![](qiniu.imolili.com/小书匠/1592274251065.png)

**离散对数问题**
*   循环群: 是指能由单个元素所生成的群.
*   对于椭圆曲线上任意一点G,一个新点 Q=kG的标量 k 形成一个循环子群
*   椭圆曲线的离散对数问题
	*   有 G和 Q,并且 Q=kG,如果k足够大,那么想要求出k这在计算上是几乎不可行的
	*   k是以G为的Q的离散对数

译者注:有限循环群同构于整数同余加法群Z/nZ，无限循环群则同构于整数加法群。每个循环群都是阿贝尔群，亦即其运算是可交换的。在群论中，循环群的性质已经被研究的较为透彻，是更为复杂的代数研究中常用到的基础工具 
[https://zh.wikipedia.org/wiki/循環群]

译者注:当我们对椭圆曲线的域进行缩减后，标量乘法仍旧”易解“，而离散对数问题成为了”难解”问题。这种双重性是椭圆曲线密码学的关键基石。

**在加密中的使用**
![](qiniu.imolili.com/小书匠/1592274270450.png)

1.只有整数
2.a和b都不大于p
3.线上点的个数=p

限制
![](qiniu.imolili.com/小书匠/1592274280784.png)
这时椭圆曲线可以被用来生成一个群

例子:
*   素数 p=23
*   y平方 mod p= x三方 + x mod p
*   选取条件 4a三方+27b平方 mod p=4 !=0
*   从点 (9,5)开始
*   23个点形成的循环群如图

![](qiniu.imolili.com/小书匠/1592274294692.png)

为什么选取椭圆曲线加密算法
*   更短的key和签名
*   生成key非常块
*   更好的美国政府支持

![](qiniu.imolili.com/小书匠/1592274299873.png)

------------
------------

### 讲义2 比特币 技术概览

讲义2 比特币 技术概览
张磊

**概要**

*   ==什么是比特币 #F44336==
*   比特币的组成
	*   用户身份
	*   交易
	*   保存记录 (区块)
	*   共识 (POW)

**比特币的基本概念**
比特币是第一个并且是最广泛使用的加密货币
数字货币完全建立在计算机科学,密码学和经济学之上
是由一个交中本聪的人在 **比特币:一个点对点电子货币系统** 中被提出的
灵感来自于区块链:一个分布式的账本
![](qiniu.imolili.com/小书匠/1592298460306.png)

**比特币的性质**
*   去中性化的:没有任何一个机构控制网络,他在计算机上运行传播在世界各地
*   匿名的:用户只有账户地址,不适用真是身份交易
*   不可变:基本不可能随任何人的意愿改变交易历史
*   可信的:用户不需要新人任何人就可以是系统正常工作
*   透明的:任何用户都由整个交易历史的本地副本 包含所有的信息

**比特币之前**
*   密码朋克:是一群倡导通过使用密码学来保护个人隐私的人

![](qiniu.imolili.com/小书匠/1592298706845.png)

[A Cypherpunk的宣言](https://www.activism.net/cypherpunk/manifesto.html)

早期的尝试
*   hashcash:通过增加时间和计算成本,用来反垃圾邮件的机制
*   B-Money:一个匿名,分布式的电子货币系统,描述了一种类似比特币的核心实现
*   比特金:-一种分布式创建不可伪造工作量证明的系统

译者注:hashcash:在电子邮件的消息头中，增加一个 hashcash 戳记（hashcash stamp）散列值;该散列中包含收件人地址，发送时间，salt，该散列值特别之处在于它至少前20位必须是0才是一个合法的hashcash戳记。为 了得到合法的散列值，发送者必须经过许多次尝试（改变salt值）才能获得。一旦生成戳记，不希望每一个给我发送邮件的垃圾邮件制造者都能重复使用它。所 以，hashcash 戳记要带一个日期。这样可以指定时间更早的戳记是非法的。另外 hashcash 的接收端要实现一个double-spending数据库，用来记录戳记的历史信息。



**概要**

*   什么是比特币
*   比特币的组成
	*   ==用户身份 #F44336==
	*   交易
	*   保存记录 (区块)
	*   共识 (POW)

**用户身份**
标识:私钥+公钥
*   公钥用来接收,私钥用来赎回
*   随机选择私钥
*   公钥通过椭圆曲线加密私钥生成ECC
ID安全:2的160次方种可能性

**比特币钱包**
*   什么是钱包呢
	*   持续跟踪你的私钥
	*   允许你操作发送和接受比特币
	*   跟踪你在一个或多个比特币地址上的余额
	*   保存你的交易历史
*   钱包的形式
	*   热钱包 在线:智能手机app,在线网络钱包
	*   冷钱包 离线:纸钱包,钱包硬件,脑钱包 助记词



**概要**

*   什么是比特币
*   比特币的组成
	*   用户身份
	*   ==交易==
	*   保存记录 (区块)
	*   共识 (POW)

UTXO模型 (未使用的交易输出)
每个交易花费的都是从之前的交易输出而来
钱包种的纸质账单:
*   每个账户都跟踪总帐上增加了多少钱
*   我们支付一个或多个账单,需要足够的花费并且有可能收回一些找零
*   每个账单只能被支付一次

![](qiniu.imolili.com/小书匠/1592298706846.png)

UTXO例子
![](qiniu.imolili.com/小书匠/1592298706974.png)
*图片来源：比特币开发者指南*

译者注:关于UTXO的模型,交易花费,和若干比特币交易标准的介绍就不翻译了,推荐看这篇blog,有较为详细的解释交易花费
[交易标准 P2PKH、P2PK、MS（限15个密钥）、P2SH和OP_Return](https://blog.csdn.net/jerry81333/article/details/56824166)

为什么使用 P2SH
主要是将较为复杂的脚本制作交给了接收方
*   发送方可以付款给任意赎回脚本而不需要知道其花费的条件
*   发送方可以使用短地址付款,减少人为的失误
*   较少了交易体积,减少了手续费

-----------

**概要**

*   什么是比特币
*   比特币的组成
	*   用户身份
	*   交易
	*   ==保存记录 (区块) #F44336==
	*   共识 (POW)

**区块链**
我们怎么储存交易? 分布式的数据库
*   区块的链,每个区块都有一堆交易
*   每个区块都引用了前一个区块
*   每个用户都储存了整个账本 数据库

![](qiniu.imolili.com/小书匠/1592298706848.png)

梅克尔树
![](qiniu.imolili.com/小书匠/1592298706954.png)

防篡改的数据库
![](qiniu.imolili.com/小书匠/1592298706850.png)

![](qiniu.imolili.com/小书匠/1592298706852.png)

译者注:
[Merkle Patricia Tree 梅克尔帕特里夏树（MPT）规范](http://me.tryblockchain.org/Ethereum-MerklePatriciaTree.html)
[Merkle Tree（默克尔树）算法解析](http://www.cnblogs.com/fengzhiwu/p/5524324.html)

**挖矿**

我们怎么更新这个账本数据库呢?
*   矿工(区块挖矿节点)创建包含未确认交易的一个区块
*   矿工把新区块加入到它的区块链种并将其广播到网络种
*   其他用户校验该被提议的区块并将其保存到自己的区块副本中
*   其他用户将区块继续在网络中转发

-------------

**概要**

*   什么是比特币
*   比特币的组成
	*   用户身份
	*   交易
	*   保存记录 (区块)
	*   ==共识 (POW) #F44336==

**共识问题**
矿工广播新区快,每个节点不需要和其他节点进行讨论,直接接受正确的区块

*   如果在不依赖于一个中心机构的情况下达成一个统一的账本版本
*   如果每个节点都是自己单独做决定,那我们又是怎么确认没有人在欺骗呢?

**共识攻击**
双花
![](qiniu.imolili.com/小书匠/1592298706856.png)

女巫攻击 (51%攻击)
![](qiniu.imolili.com/小书匠/1592298706858.png)

**工作量证明**
比特币的一部分原象性hash难题
*   寻找一个随机数,使得计算的结果小于指定值
*   性质
	*   难以计算
	*   易于验证
	*   参数化控制指定的值以在2周内生成2016个区块.10min一个区块

![](qiniu.imolili.com/小书匠/1592298706860.png)

**比特币主链**
最长链法则
*   它保证了整个网络确认拥有最多算力的链未主链
*   不在主链的区块被共识认为是无效的
*   矿工永远会在他的区块副本顶部进行挖矿

![](qiniu.imolili.com/小书匠/1592298706862.png)

**块确认**

*   在 n个区块后确认交易
	*   等待，直到该交易是在主链上有n-1的后续的区块创建
	*   交易在后面的这些区块每一个区块得到一个确认
	*   这是一种基于区块的确认数来确认是否需要回滚区块和交易
*   事实上
	*   工作量证明和区块确认的机制使得双花和女巫攻击非常昂贵
	*   恶意节点需要整个网络一半以上的算力,又名51%攻击

**共识机制的变更**
硬分叉和软分叉
![](qiniu.imolili.com/小书匠/1592298706865.png)

![](qiniu.imolili.com/小书匠/1592298706867.png)

**总结:比特币系统**
Id:私钥+公钥
交易:UTXO交易模型
数据记录:分布式数据库 区块链
共识:通过工作量证明保持单一版本

---------------------
---------------------

### 讲义3 比特币 挖矿 和 安全

讲义3 比特币 挖矿 和 安全
张磊

**概要**
*   比特币挖矿
	*   ==节点类型 #F44336==
	*   挖矿 & 共识
*   比特币安全
	*   双花
	*   矿池攻击
	*   自私挖矿

**节点功能**
*   一个比特币节点包含以下功能：转发，区块链数据库，挖矿和钱包服务
*   节点的功能：
	*   网络转发：使用比特币P2P协议
	*   全节点：维护一个最新的包含全部数据的区块链
	*   挖矿：通过解决hash计算工作量证明来创建新区块
	*   钱包：提供钱包服务
![所有节点功能](qiniu.imolili.com/小书匠/1592298706870.png)

**节点类型**
不同节点类型所需要拥有的节点功能

![比特币核心客户端](qiniu.imolili.com/小书匠/1592298706873.png)

![区块链全节点](qiniu.imolili.com/小书匠/1592298706875.png)

![轻量节点](qiniu.imolili.com/小书匠/1592298706961.png)

![独立矿工](qiniu.imolili.com/小书匠/1592298706964.png)

![矿池协议服务器](qiniu.imolili.com/小书匠/1592298707020.png)

![矿池挖矿节点](qiniu.imolili.com/小书匠/1592298707023.png)

*图源:Mastering Bitcoin*

**全节点和轻量节点**

全节点
*   保存整个区块链的数据副本
*   无需外在依赖可以自主权威的验证任何交易
*   需要满足200G硬盘，2G内存等系统要求
轻量节点
*   能在资源有限的设备上运行：比如只能手机或平板
*   通过全节点来发送交易
*   对每一个区块仅下载区块头而不是整个区块数据
*   通过SPV来校验交易的有效性
SPV一种用于验证特定交易是否被包括在一个块中而无需下载整个区块的方法
*   只需要下载最长链的区块头
*   找到将交易关联在区块上的梅克尔树分支
*   然后再从全节点中下载相关的hash值

![](qiniu.imolili.com/小书匠/1592298707148.png)

> 译者注：如果简单地实现SPV的客户端有些潜在缺陷首先，虽然SPV客户端不会轻易上当，将区块中不存在的交易当作存在，反之却不成立。一个完整的节点可以通过疏漏撒谎，让SPV客户端相信没有交易发生。这可以被认为是拒绝服务攻击的一种形式。一种缓解策略是与许多完整节点连接，然后向每个节点发送请求。然而，这种策略会被网络划分或女巫攻击所打败.
其次，SPV客户端不是下载所有区块然后丢弃不需要的，而是仅下载与其密钥有关的交易，这的确可以节省很多带宽，但这就会让全节点对这个用户的公钥地址有一个完整视图，必然会有一个巨大的隐私泄露。

----------------

**概要**

*   比特币挖矿
	*   节点类型
	*   ==挖矿 & 共识 #F44336==
*   比特币安全
	*   双花
	*   矿池攻击
	*   自私挖矿

**比特币挖矿**
比特币挖矿的目的
*   这不仅仅只是凭空造出新的比特币，这是一种激励机制
*   比特币达成避免集中，达成分散安全的原理
挖矿收益减产
*   每一个区块被挖出的时候新的比特币就产生了
*   每个块产出的比特币数量被设置为每210,000的块减少50% （约4年减产一次）
*   初始奖励是每个块50个比特币
*   比特币总量有上限，2100万

![](qiniu.imolili.com/小书匠/1592298707150.png)

**挖矿程序**
一个全节点矿工需要如下步骤:
*   下载并保存整个比特币区块链
*   独立校验所有交易
	*   把有效但尚未确认的交易保存在内存池中
	*   有一个保存了所有验证解锁脚本的清单 （P2PKH，P2SH还记得吗）
*   将交易进行打包
	*   每一个区块的第一个交易是一个特殊的coinbase交易，其中指定了挖矿的奖励（产生新的比特币）
	*   coinbase交易有一个coinbase的input和一个包含挖出当前区块矿工地址的output
	*   每个交易支付的交易费也会包含在区块中 (译者注：金额也是在coinbase中)
*   构建区块头
	*   将未确认的交易按照梅克尔树进行hash计算
	*   计算前一个区块头的hash
	*   通过pow算法找到一个nonce随机数满足指定条件
*   广播一个新区块
	*   其他节点会独立地通过一个条件清单对新区块进行校验
	*   如果新区块是有效的，其他节点会接受它并将它继续在网络中传播
	*   其他节点将新区块放在区块链中，并会选择最长链

**区块链分叉**
比特币分叉
*   当两个或多个区块拥有同样的高度时，一个分叉就会产生
*   通常分叉发生在同时又两个或更多区块被挖出的时候，当然也可能是攻击的一部分
*   分叉可以随着更高高度区块被挖出时，被节点选择最长链的原则而解决

![](qiniu.imolili.com/小书匠/1592298707152.png)

共识例子1
分叉前 所有节点都有相同的共识
![](qiniu.imolili.com/小书匠/1592298707162.png)

共识例子2
分叉事件 两个块同时被挖出
![](qiniu.imolili.com/小书匠/1592298707164.png)

共识例子3
两个区块同时广播并且分裂了网络
![](qiniu.imolili.com/小书匠/1592298707166.png)

共识例子4
其中一个分叉有新块被挖出，这就使网络从分叉中恢复
![](qiniu.imolili.com/小书匠/1592298707169.png)

共识例子5
分叉被解决，网络重新在最长链上开始工作
![](qiniu.imolili.com/小书匠/1592298707173.png)

**矿池**
比特币挖矿竞争非常激烈![](qiniu.imolili.com/小书匠/1592298707154.png)

矿池允许个人矿工将他们的算力整合起来
*   减少挖矿收入的差异
*   中心化操作或者通过p2p的方式
*   矿池提供服务会收取一定的费用

**矿池是怎么工作的？**
矿池中的矿工提交 工作股份（差不多有效的区块）到矿池管理者
*   提交股份也是在解决类似的pow工作，但是难度要小的多
*   有效的区块当然也是算作股份
*   如果找到一个新的区块，矿池管理者会将区块奖励按照矿工提交的股份比例来分配
*   问题：为什么矿池中的矿工提交了股份不能将全部区块的奖励归为自己所有？

**参与矿池的模式 （矿池支付给矿工的方式）**
成比例的 (译者注 PROP)
*   一旦矿池出块后，会按照这个块中每个矿工提交工作的比例进行分配, 股份一次清算完。
*   对矿池来说是有利的
	*   个人矿工依然要承担没有出块奖励的风险
	*   矿池只需要在有出块的情况才支付给矿工
按股份支付（译者注 PPS）
*   矿池在每个块被产出时，都需要按照算力完成的股份比例支付给矿工
*   对矿工来说是有利的
	*   对于矿工来说没有收益天差地别的风险
	*   对矿工提交有效区块没有激励

> 译者注：关于矿池模式更加详细的可以参考wiki <https://en.wikipedia.org/wiki/Mining_pool>

*   PROP模式是出块才分钱，而且是根据当前块的share股份来分的
*   PPLNS是改进的方法，根据过去的若干个块一共提交的share股份来分的，PPLNS是一种包含运气成分的派息挖矿方式，如果矿池一天能够发现很多个区块，那么大家的分红也会非常多，如果矿池一天下来都没有能够发现区块，那么大家也就没有任何收益。同时，由于PPLNS下，具有一定的滞后惯性，你的挖矿收益会有一定的延迟，比如说，你加入到一个新的PPLNS矿池，这个时候你会发现前面几个小时的收益比较低，那是因为别人在这个矿池里已经贡献了很多个share了，你是新来的，你的贡献还很少，所以分红时你的收益都是比较低的。随着时间的推移，该结算的也结算了，大家又开始进行了新一轮的运算时，你就回到和别人一样的水平了。同样道理，若你离开了PPLNS矿池不再挖矿，你贡献的share还在，在此后的一段时间里，你依然会得到分红收益，直到你的share被结算完毕
*   PPS则完全取消了运气成分，相当于你租借算力给矿池，即打工模式，根据你的算力在矿池中的占比，并估算了矿池每天可以获得的矿产，给你每天基本固定的收益。
*   SOLO挖矿，一般都是拥有超大算力才可能进行solo挖矿
*   P2P挖矿，即自行组织成一个矿群挖矿，但由于网络不佳，基本已经过去时了

----------------

**概要**

*   比特币挖矿
	*   节点类型
	*   挖矿 & 共识
*   比特币安全
	*   ==双花 #F44336==
	*   矿池攻击
	*   自私挖矿

双花问题
*   同一个input被两个或更多的交易消费 译者注：一笔钱花了两次
*   接受未确认的交易是不安全的 译者注 （0确认）
*   种族攻击：一个欺诈者
	*   攻击者把支付给商家以购买商品的交易直接发送给商户
	*   同时攻击者把消费同样input的交易但是output指向自己的交易发送到其他网络中
*   芬尼攻击：一个恶意矿工
	*   挖出一个包含发送币到自己账户的交易的块
	*   攻击者并不广播该块，而是将相同input的比发送给商家获取商品或服务
	*   如果商家接受0确认，则广播自己挖到的快

> 译者注：这里介绍的比较简单，我个人喜欢将双花分为 0确认攻击 和 算力攻击。
0确认攻击有上文所述的 种族攻击 和芬尼攻击
==种族攻击 #F44336==主要通过控制矿工费来实现双花，即将一个input构建两个交易，发送给商家的手续费低，而发送给自己的手续费高，同时进行广播，按照现在的打包顺序肯定是发送给自己的交易被打包，如果商家接受0确认交易则攻击成功。
==芬尼攻击 #F44336==来源于Hal Finney，Hal Finney是第一个描述双花攻击之0确认（未确认）交易的人。芬尼攻击主要通过控制区块的广播时间来实现双花，这需要一定的算力来构建区块。
    
> 不管怎么说，接受0确认交易是非常非常危险，那么1次确认呢，当然也是有很大漏洞的啊。
1确认攻击叫==Vector76攻击 #F44336==，是种族攻击和芬尼攻击的组合，也就是交易已经有了一个区块确认，依然被回滚了。实现的方式略复杂，如果商户的客户端接收1次确认支付，并且直接暴露了其直连的节点就可以被实施了。攻击者控制了两个全节点，A直连在商户客户端，B与其他多个节点相连。然后攻击者构建了类似种族攻击的两个但并不进行广播，而是仅仅在打包了给商户的交易的节点A上进行挖矿，攻击者只要挖到区块后依然不进行广播，而是同时把给商户的交易在A节点广播，把双花的交易在节点B上广播。这时攻击者会进行等待，由于发送到节点B的双花交易手续费高，所以下一个区块会将其打包，而给商户的交易会认为是无效的。但这时攻击者立刻将自己已经挖好的区块在节点A进行广播。此时分叉相同高度的两条链对两个交易都有1个确认。商户接受了1次确认交易提供了商品后会发现这条链就不会有新区块了，因为发送到节点B链传播的网络更多，那么后续在这条链上工作的矿工节点也更多从而挖出更新的块成为最长链，攻击成功。

> 如果说上述攻击是因为商户自己的问题，那么算力攻击就只能让整个网络来背锅了。最著名的当然是 51%攻击，又被称为Majority attack，只要你拥有51%的算力，那么在这段时间内，你几乎可以回滚任何交易那么以比特币现在的全球算力情况，达成51%算力可以说是非常非常难了，但也不可以掉以轻心，因为 替代历史攻击（Alternative history attack） 依然可以在等待交易确认的时候被攻击成功,该攻击存在很大的机会成本（风险），所以博弈的成本是非常大的。实施很简单，即商家在等待了N次确认后发送了商品确认交易成功，但攻击者在发送交易的同时分叉挖矿，凭借其高算力，挖到了N个以上的区块就可以实现双花，如果没有，那么攻击就失败了。

**抵御双花**
比特币确认
*   比特币确认表示了当前最长链中已经有多少个区块包含了这个交易
*   比特币用户通过等待确认数，来避免收到的交易被双花
*   目前普遍认为6个确认就表示了足够的安全性
*   那么多少确认数才是足够的安全呢？

**分析**
一个追赶游戏:攻击者试图使一条被替换的链来代替诚实的链设：
*   z : 交易z个确认后会被接受
*   p : 诚实节点们找到新区块的概率
*   q : 攻击者找到新区块的概率
*   挖出块的数量遵循泊松分布
*   v : 诚实节点挖出z个区块的时间内，攻击者能挖出的区块

![](qiniu.imolili.com/小书匠/1592298707157.png)

*   攻击者在落后m个区块后追平的概率是

![](qiniu.imolili.com/小书匠/1592298707160.png)

*   攻击者在z个确认后追上诚实链的概率

![](qiniu.imolili.com/小书匠/1592298707175.png)

![](qiniu.imolili.com/小书匠/1592298707222.png)
*图片来源：Blockchain 伯克利分校*

> 译者注：很直观的可以看出如果攻击者拥有全网10%的算力,5确认之后即可,如果他有30%的算力,则需要24个区块后，控制的算力越多，需要等待的确认数就更多

---------

**概要**

*   比特币挖矿
	*   节点类型
	*   挖矿 & 共识
*   比特币安全
	*   双花
	*   ==矿池攻击 #F44336==
	*   自私挖矿

**选择矿池**
在多个矿池中选择增加收入
怎么在PPLNS和PPS的挖矿方式中选择
![](qiniu.imolili.com/小书匠/1592298707178.png)

**破坏攻击**
恶意矿工的策略
*   只提交近有效的块，但保留有效块
*   导致矿池损失破产
*   如果他有自己竞争的矿池则收益更多
*   举个例子：给定一个矿工有 20h/s ，拥有整个网络20%的算力，每个区块奖励1个btc，那么矿工每挖出一个有效区块可以得到0.2个btc，如果他又投入了1h/s的算力

![](qiniu.imolili.com/小书匠/1592298707180.png)

译者注：按照矿池占全网算力的比例来分配自己的算力是最优解

**埋伏攻击**
恶意矿工的策略
*   同时在几个矿池中进行挖矿 （等待阶段）
*   当他找到了一个区块时 （伏击阶段）
	*   保留这个区块
	*   将自己的所有算力切换到找到块的的矿池
	*   将找到的块提交然后回到等待阶段

为什么这么做对攻击者有利
直觉上：找到区块的矿池好像更有赚头，但可以显而易见对恶意矿工有利

译者注：随着算力的不断激增，新增加的个人算力其实微不足道，而权衡微弱收益差于管理矿池的成本之间，破坏攻击实际的收益很微小。而随着PROP模式改为PPLNS模式，埋伏攻击也无法在切换算力后立刻得到很多奖励，同样是一个收益权衡的情况，也许在个人拥有很大算力的时候，才会使这种收益差显示出来。

**矿池战争**
两个矿池之间的战争
*   矿池战争类型于两个玩家之间的游戏
*   每个玩家都可以选择攻击或不攻击
*   玩家之间不能合作，而且从自己的角度来看，如果不攻击就不能赚更多
*   犹如囚徒困境，最终的纳什均衡点就是矿池们都选择进行攻击

![](qiniu.imolili.com/小书匠/1592298707211.png)

译者注：
[囚徒困境](https://zh.wikipedia.org/wiki/%E5%9B%9A%E5%BE%92%E5%9B%B0%E5%A2%83)
[囚徒困境纳什平衡 ](https://zh.wikipedia.org/wiki/%E7%B4%8D%E4%BB%80%E5%9D%87%E8%A1%A1%E9%BB%9E)

----------------

**概要**

*   比特币挖矿
	*   节点类型
	*   挖矿 & 共识
*   比特币安全
	*   双花
	*   矿池攻击
	*   自私挖矿

**自私挖矿**
恶意矿工的策略
*   当他找到一个新区块的时候并不像正常矿工一样马上广播
*   让诚实的矿工继续在原来的链上挖矿，而他自己则在他自己的链上继续挖
*   如果诚实矿工也找到了新区块，如果他找到了两个区块，则立刻广播两个区块使他自己的链成为最长链

![](qiniu.imolili.com/小书匠/1592298707212.png)

**广播竞赛**
如果诚实的矿工先于恶意矿工发现第二个区块前就找到了新区块的话会发生什么？
*   比特币网络规定，如果有两个链是相同的高度，则挖先收到的那条
*   永远是第一个收到的攻击：恶意矿工拥有非常多的传播节点来帮助广播他的区块
*   更实际的方法是：诚实矿工随机选择相同高度的区块来继续挖矿

**分析**
记
*   a : 恶意矿工的算力占比
*   v ：诚实矿工选择挖自私链的比例
*   state 0: 没有分叉，只有一条最长链的情况
*   state 0' : 有两条相同高度的公共分支，一是主分支，另一条则是恶意矿工私有的自私链
*   state i(i=1,2,3...) : 恶意矿工的自私链领先于主分支 i 个区块

马尔可夫链：
![](qiniu.imolili.com/小书匠/1592298707229.png)

在下列条件成立时，恶意矿工能获得远比他算力 a占比大的多的收益
![](qiniu.imolili.com/小书匠/1592298707261.png)

译者注： 所以不要以为只有51%攻击会击垮一条链，25%也可以。个人推荐还可以看一下V神的这篇文章Selfish Mining: A 25% Attack Against the Bitcoin Network<https://bitcoinmagazine.com/articles/selfish-mining-a-25-attack-against-the-bitcoin-network-1383578440/>

------------
------------

### 讲义4 以太坊(1)

讲义4 以太坊
李崇

**概要**
*   ==以太坊入门 #F44336==
*   以太坊账户
*   以太坊状态转换
*   智能合约
*   以太坊区块
*   以太坊和比特币的比较
*   区块链的物理限制

**动机**
*   比特币维护了一个没有任何固定价值支撑，或中央发行人的去中心化p2p在线货币
*   工作量证明 POW 的基础是一个 first-to-file 系统，这可以通过交易的到达顺序来达成一致
	*   但几十年来，决定两笔交易谁先到达的方法阻碍了数字货币的发展
*   区块链概念为什么仅仅被用在钱上面？

**什么是以太坊**
*   以太坊是一个数字货币研究者，程序员 维塔利克·巴特林 （V神）在2013年提出的
*   以太坊会提供一种成熟的图灵完毕的编程语言，只需要简单的编写几行代码就可创建任何应用程序-智能合约
*   以太坊的关键组件
	*   以太坊账户
	*   状态交易
	*   以太坊区块
	*   智能合约
	*   一致性算法

![](qiniu.imolili.com/小书匠/1592298707264.png)

**以太坊用例**
![](qiniu.imolili.com/小书匠/1592298707450.png)

------------

**概要**

*   以太坊入门
*   ==以太坊账户 #F44336==
*   以太坊状态转换
*   智能合约
*   以太坊区块
*   以太坊和比特币的比较
*   区块链的物理限制

**以太坊账户**
*   账户地址:20个byte数字
*   账户状态包含：
	*   账户随机数：一个用来保证每个交易只会被处理一次的计数器。如果是合约账户，这代表了由该账户创建了合约的数量。
	*   账户余额：用以太坊货币最小的单位wei计数的数字
	*   合约代码：如果存在
	*   合约存储：默认为空

**以太坊账户 - 以太**
“以太”是以太坊的主要内部加密燃料，用于支付交易费用。
![](qiniu.imolili.com/小书匠/1592298707482.png)为

什么最小单位是 wei
1998年， Wei Dai 的B-money成为第一个提出通过解决数学难题和分布式共识来创造货币的提案。

**以太坊账户 - 类型**
![](qiniu.imolili.com/小书匠/1592298707405.png)

> 译者注：一般来说，有两种类型的账户：外部所有的账户，由私钥控制；合同账户由合同代码控制。 外部所有的账户没有代码，人们从外部所有账户发送消息，以创建和签署交易; 在合同账户中，合约账户每次收到消息后，代码激活，将允许对内部存储进行读写和发送其他消息或者依次创建合约。

----------------

**概要**

*   以太坊入门
*   以太坊账户
*   ==以太坊状态转换 #F44336==
*   智能合约
*   以太坊区块
*   以太坊和比特币的比较
*   区块链的物理限制

**比特币的状态转换**

*   比特币这样的加密货币账本可以被认为是一种状态转换系统
*   比特币中的“状态”是已经产生和尚未用完的所有货币(UTXO)的集合

![](qiniu.imolili.com/小书匠/1592298707412.png)

**以太坊状态转换**

*   以太坊可以被看作是一个以交易为基础的状态机
*   状态转移函数

![](qiniu.imolili.com/小书匠/1592298707431.png)

*   所有交易都需要支付计算的成本，费用是通过GAS来进行计算的

**以太坊状态转换 - Gas**

*   gas是交易发起人作为手续费预先支付的
*   交易的每一个步骤都有一个预先定义好的gas数量
*   每个交易都会指定愿意为执行可以消耗的gas数量
*   为什么需要设置gas

![](qiniu.imolili.com/小书匠/1592298707429.png)

**以太坊状态转换 - 示例**

*   从地址4718bf7a转移2个以太到地址741f7a2开始
*   ETH 数据在地址741f7a2被存储在索引3上

![](qiniu.imolili.com/小书匠/1592298707484.png)

**以太坊状态转换 - 算法**
以太坊状态转换函数定义工作
*   检查交易是否被构建完好（例如，有正确的值），签名是否正确，随机数是否与发送者账户的随机数匹配。如果不是，返回错误。
*   通过 STARTGAS * GASPRICE计算出交易费用，确定发生地址来自于签名，从发送者账户减去费用，同时增加发送者的随机数。如果没有足够的余额，返回错误。
*   初始化 GAS = STARTGAS，在交易中支付确定每字节数量的gas，并且确保交易拥有足够的以太来支付费用
*   在此步骤中，从发送者账户转移交易数额至接受者的账户。如果接受者的账户不存在，创建一个。如果接受者账户是一个合约，运行合约代码要么完成，要么用光了所有的gas。
*   如果是因为发送者没有足够的钱而导致转移失败，或者是代码运行用光了gas，除了支付的费用外，恢复所有状态的更改，并将费用支付给矿工的账户。
*   最后，如果手续费还有剩余则作为找零返还给发送者，支付消耗的费用给矿工。此时，方法会返回结果状态。

------------

**概要**

*   以太坊入门
*   以太坊账户
*   以太坊状态转换
*   ==智能合约 #F44336==
*   以太坊区块
*   以太坊和比特币的比较
*   区块链的物理限制

**智能合约**

*   术语“智能合约”是由计算机科学家（律师） 尼克 萨博，在1996年一篇名为 “Formalizing and Securing Relationship on Public Network” 的博客中创造的。
*   所有智能合约的鼻祖是：自动售货机（yes，卖糖果苏打水）
*   自动售货机和如今的区块链智能合约做的事情是基本一致的。自动售货机经过编码已经定义好当满足一定的条件发生了什么规则的时候执行某一些操作。

**以太坊中的智能合约**

*   在以太坊网络中，智能合约是有账户创建的
*   它包含了代码定义的方法，并且可以和其他智能合约交互，做出判断，存储数据，执行交易。
*   创建者定义了合约，但是是由网络来进行执行的。
*   合约会随着整个网络的存在一直存在并执行调用，除非创建者编码设置自己销毁
*   合约几乎无所不通

智能合约 - 示例 
![](qiniu.imolili.com/小书匠/1592298707487.png)

**智能合约**

*   Solidity : 进行智能合约编程的高级语言
*   参考 <https://solidity.readthedocs.io/en/v0.5.4/>
*   Remix : 一个在线IDE，可以自动编译你的代码

![](qiniu.imolili.com/小书匠/1592298707494.png)

----------------

**概要**

*   以太坊入门
*   以太坊账户
*   以太坊状态转换
*   智能合约
*   ==以太坊区块 #F44336==
*   以太坊和比特币的比较
*   区块链的物理限制

**以太坊区块**
以太坊区块包括：
*   区块头
*   交易列表 当前区块包含的所有交易
*   叔块的区块头（叔块会在下一讲介绍）

![](qiniu.imolili.com/小书匠/1592298707499.png)

**以太坊区块头**

| 字段 | 描述 |
| --- | --- |
| Parent Hash | 父（上一个）块的Keccak 256位hash |
| OMMERS HASH | Ommers（叔伯）块的列表的Keccak 256位hash。 |
| Beneficiary | 将接收采矿奖励的开采收件人的160位地址。 |
| State Root | 状态字典树的根节点的Keccak 256位hash。所有事务都得到处理并最终确定后。 |
| Transactions Root | 交易树结构的根节点的Keccak 256位hash。 |
| Receipts Root | 交易收据树的根节点的keccak 256位hash。数组是由包含块中的所有交易的数据计算的。每个事务被处理并包含有用的交易后的信息后，生成交易收据。 |
| Logs Bloom | 这是由记录器的地址，并从每笔交易收据块包含的交易清单的日志条目的布隆过滤器。 |

| Difficulty | 当前块的难度级别。 |
| --- | --- |
| Number | 之前区块的数量，创世块高度是0 |
| Gas Limit | 区块设置可以消耗的gas限制 |
| Gas Used | 区块中所有交易消耗的gas总数 |
| TIMESTAMP | 时间戳 |
| Extra Data | 额外的数据字段可以用来存储与块有关的任意数据。 |
| MIXHASH | 一个256位的hash和nonce随机数用来证明已经执行了工作量来创建该区块 |
| NONCE | 同上 |

---------------------

**概要**

*   以太坊入门
*   以太坊账户
*   以太坊状态转换
*   智能合约
*   以太坊区块
*   ==以太坊和比特币的比较 #F44336==
*   区块链的物理限制

以太坊 vs. 比特币
![](qiniu.imolili.com/小书匠/1592298707438.png)
![](qiniu.imolili.com/小书匠/1592298707440.png)

---------------------

**概要**

*   以太坊入门
*   以太坊账户
*   以太坊状态转换
*   智能合约
*   以太坊区块
*   以太坊和比特币的比较
*   ==区块链的物理限制 #F44336==

**区块链的物理极限**

*   比特币对于最多50%的算力之下都是非常安全的
*   但是，吞吐量和延迟就非常差（为什么）
*   区块链协议性能的根本限制是什么？
*   思考：区块链协议是运行在物理网络上的一些分布式节点上的，因此，它的性能就受到了网络的限制。
*   网络的两个基础属性：
	*   通信的容量 C ： 每秒发生的交易量
	*   网络中的光速传播延迟 D：以秒来计量
*   容量C和传播延迟D限制了信息在网络中传递的速率

设定：
*   β：在不影响系统安全性的情况下，攻击者可以控制全网算力中的比例
*   λ：吞吐量-每秒确认的交易 TPS
*   γ：确认延迟，秒计量
*   ε：一个已经被确认的交易在后面的账本中被回滚的概率

*   假设：每个交易至少要在网络中通信一次
*   λ < C ，γ > D 是显而易见的
*   假设一个区块中可以包含 B 个交易，那么一个交易最多有可能需要 Cγ/B个区块才能被确认。
*   在此区间，这些区块可以认为是指定交易的确认投票。

*   正常来说除了极端情况，我们假设这些区块中的 β < 0.5 (下面公式中的p) 是攻击者的。
*   攻击者区块比诚实区块还多的概率是什么，如果发生这种情况，交易确认就得不到保障。
*   假设 投票/区块 是独立的
	*   X 是攻击者的区块数
	*   X 有二项分布
	*   n = Cγ/B 是区块的总数
	*   互补累积概率分布函数是

![](qiniu.imolili.com/小书匠/1592298707441.png)

*   临界值

![](qiniu.imolili.com/小书匠/1592298707443.png)

*   在我们的案例中

![](qiniu.imolili.com/小书匠/1592298707448.png)

*   γ > D 是显而易见的
*   如果

![](qiniu.imolili.com/小书匠/1592298707502.png)等待时间是受到了传播延迟的限制，另一方面，它也受到确认的可靠性需求限制。


**示例**

*   带宽传输速率是 20Mbits每秒
*   光速全球传播延迟 D=0.2秒
*   一个交易的打消是 100字节
*   C= 25000个交易每秒
*   于是有 C*D=5000个交易
*   如果回滚几率ε足够小的情况下，这意味着确认的延迟受到了传播延迟0.2秒的限制
*   以太坊中：λ=15 TPS，λ 需要3 分钟 来保证 β=0.3的情况下错误概率只有0.04 (即以太坊中，受到TPS的限制，如果攻击算力的交易占了30%的话需要等待3分钟才能保证96%的概率交易不发生错误回滚)
*   因此，以太坊远远没有到达物理的极限

> 建议阅读的内容
*   以太坊白皮书
*   [智能合约：区块链技术将取代律师](https://blockgeeks.com/guides/smart-contracts)
*   [POW vs POS:基本挖矿指导](https://blockgeeks.com/guides/proof-of-work-vs-proof-of-stake)

-----------------
-----------------

### 讲义5 以太坊(2)

讲义4 以太坊 2
李崇

**概要**

*   ==性能的权衡 : 吞吐量 和 安全性 #F44336==
*   以太坊共识 : 幽灵协议
*   POS 协议

**如何提高吞吐量?**

*   区块链网络的吞吐量取决于两个关键因素:
	*   区块的创建速度:降低挖矿难度就可以加快区块的创建速度
	*   区块大小:建立更大的区块
*   为什么不只是改变这两个参数来提高吞吐量呢?

**加速区块的创建速度**

*   当最新的区块在主链上传播时,更多的区块正在被创建
*   这些区块由于频繁创建但并没有跟上最新的区块,它们并不是在最长链上
*   这意味着随着传播的延迟,加速区块的创建会导致更多的分支,而不是增加最长链上的速度.

![](qiniu.imolili.com/小书匠/1592298707508.png)

假设E3时最新的区块,但是当它在网络中传播的时候,块3C和3D被其他的矿工挖出来了,这两个区块并没有跟在最长链3E后面而是跟在2C后面成了分支.

**更大的区块**

*   上文说到由于延迟导致节点没有更新到最长链的时候,它创建的新区快不会附加在最长链上而是成为了分支
*   而当区块变大的时候,自然的需要更长的时间来在网络中传播
*   延迟增加,因此也会造成更多的分叉

![](qiniu.imolili.com/小书匠/1592298707536.png)

**降低安全性**
![](qiniu.imolili.com/小书匠/1592298707538.png)

*   大区块和快速创建区块都会造成更多的链分支
*   假设攻击者正在挖自己的一条链,他挖出的块总是自己的最新块
*   更多的分支以为着攻击者更容易使自己的链成为最长链(译者注:其他人的算力都被分叉稀释了算力)

在吞吐量和安全性之间权衡
增加块大小或出块块率可以增加吞吐量，但是也会降低安全性增加被双花攻击的风险.

![](qiniu.imolili.com/小书匠/1592298707614.png)

----------------------

**概要**

*   性能的权衡 : 吞吐量 和 安全性
*   ==以太坊共识 : 幽灵协议 #F44336==
*   POS 协议

**Greedy Heaviest-Observed Sub-Tree (GHOST协议)**

*   据观测:就算不在主链上的区块依然可以拥有权重
*   想法:一种新的父级选择策略-最重的树协议
*   最重 : 拥有最多的POW工作量证明

![](qiniu.imolili.com/小书匠/1592298707629.png)

GHOST算法遵循从树的根（创世块），并在每个叉选择拥有最重的子树块作为最长链
如上图,如果根据最长链原则,1B,2D,3F是主链
这时攻击者私密链 1A 2A 3A 就可以攻击成功了
但是工具GHOST协议 1B 2C 3D 4B才是最长链

**GHOST的基本属性**

*   收敛:每个区块在有限的时间内要么被完全接受,要么就被完全废弃
*   抵御50％的攻击：这是GHOST链选择的主要优势，即使在高速区块创建或网络中有很大延迟的时候需要如此.

**收敛证明**

![](qiniu.imolili.com/小书匠/1592298707633.png)

*   对于每一个区块 B,都定义一个 ΨB 表示它被全部节点接受或废弃的最早时间.需要证明 E[ΨB] < 无穷
*   设 D是网络的延迟直径, 设 time(B) 是区块 B 的创建时间
*   假设 t , t >time(B) 是区块B既没有被接受也没有被放弃的时间距离
*   定义一个事件 Et : 下一个区块是在 t+D 和 t+2D 之间创建的 ,并且直到 t +3D 都没有其他区块被创建
*   如果这个事件发生了,区块B就已经被全部节点接受或者放弃了,为什么?

![](qiniu.imolili.com/小书匠/1592298707634.png)

![](qiniu.imolili.com/小书匠/1592298707636.png)

在 t 和 t+D 之间,所有节点都已经同步完了现存的区块,也就是说,所有节点都有了相同的树结构.考虑以下两种情况:

1.如果只有一条主链,结束!
2.如果至少有两条拥有相同子树权重的叶链,下一个新区块的时候也会在 t+3D的时候打破这个平局,也就是说恢复到一条主链, 在那个时候,区块B同样要么被所有节点接受,要么被废弃,结束!

![](qiniu.imolili.com/小书匠/1592298707667.png)

鉴于区块创建的分布(比如泊松分布),事件 Et发生的概率是一个有下限的正数并且独立于 t 
由于 等待几乎是不可避免的,所以可以期望第一个 Et事件发生的等待事件是有限的,而ΨB停止时间是有上限的 (为什么)
所以 E[ΨB] < 无穷.
*Chapter 10.11, Williams, D.: Probability with martingales. Cambridge university press (1991)*

**以太坊中的GHOST**

*   在以太坊中,区块创建的平均时间大约是15秒
*   以太坊的平均块间隔时间很短，对区块链网络的速度有很明显的效果,在2017年只使用了整个网络的0.06-0.24
*   因此我们需要 GHOST

*   不在主链上的块叫做陈旧块
*   每一个陈旧块都是主链上的直系块的的后代,并且在分叉的最多6个区块内(为什么?)后后面的(侄子)被引用为叔伯块
*   一个正式区块最多可以引用2个叔块
*   叔块:有正确的头,但忽略其负载的数据

![](qiniu.imolili.com/小书匠/1592298707668.png)

*   以太坊采矿奖励：
	*   主链上的区块奖励:区块奖励+gas手续费+每个包含的叔块1/32的区块奖励
	*   叔块的矿工奖励:奖励范围在6个区块内从 7/8个区块奖励递减到2/8个区块奖励
*   分叉超过一个区块,或者太远的区块不能被引用作为叔块

分叉超过一个区块的,不能被引用作为叔块

![](qiniu.imolili.com/小书匠/1592298707670.png)

块b2a是第一代叔块被b3a包含,块b3b是第二代叔块被b5包含,但b4b就不能被引用为叔块,因为它的父级b3b不是主链中区块

----------------

**概要**

*   性能的权衡 : 吞吐量 和 安全性
*   以太坊共识 : 幽灵协议
*   ==POS 协议 #F44336==

对pow说不,为什么?
作量证明的缺点:计算需要大量的能源消耗
巨大的电力成本 不环保

![](qiniu.imolili.com/小书匠/1592298707715.png)

大约65%的算力被4个矿池占据这些矿池可以很简单的联合起来发动51%攻击

![](qiniu.imolili.com/小书匠/1592298707713.png)

**权益证明共识**

*   POS是作为POW的替代品被提出的
*   第一次是2012在Peercoin中被提出的
*   用户需要拥有一定的货币从而证明他们拥有股份权益
*   理念:如果拥有更多的数字货币就可以赢
*   各种股权的形式:币〇证明,燃烧证明等

**POS示例:币龄**

*   币的年龄是从这枚币最后一次使用或获得开始的
*   币龄在区块被挖出时重置
*   矿工因为一段时间保持不花费币而得到奖励

Peercoin结合了POW和币龄
pow挖矿难度和币龄成反比

**以太坊中的POS**

*   随着Serenity宁静版本的到来,以太坊会使用POS代理POW
*   Serenity并没有一个确切的时间点 ( 译者注:当然时随着一次次难度炸弹的推迟 )
*   阅读:[什么时以太坊宁静](https://medium.com/utopiapress/what-is-ethereum-serenity-f433d824c974)
*   Caspar: 一个POS的协议用来代替POW

**无利害攻击问题**

*   如果你是一个验证器，那么你可以简单地把你的钱放在两个链上获得两份收益
*   不管发生什么事，尽管你的行为是恶意,你也永远是赢家，没有什么可失去的

![](qiniu.imolili.com/小书匠/1592298707673.png)

**卡斯帕**

*   理念：验证者在他们出块钱需要付出保证金。如果验证者做了一个恶意的行为,他们将立即得到惩罚,他们的股份会被削减.
*   卡斯帕设计了更为严厉的激励机制来保证网络的安全性,包括无论矿工是否有意或无意脱机都将得到惩罚.

-----------------
-----------------

### 讲义6 分布式系统共识

讲义6 分布式系统共识
张磊

**概要**

*   ==分布式系统 #F44336==	
	*   定义 性质
	*   CAP定理
*   基于投票的共识
	*   拜占庭将军问题
	*   PBFT共识算法
*   基于凭据的共识
	*   概述
	*   POS

**为什么要使用分布式系统?**
当今的计算和信息系统本身就是分布式的:

*   地理：大型组织和企业在地理上是分散开的
*   平行度：多核处理器或计算机集群被用来加快计算速度
*   可靠性：数据在不同的机器上存在多备份，以防止数据丢失
*   可用性：数据在不同的机器上存在多备份,允许在任何时间地点访问,并减少延迟

**什么是分布式系统**
定义:
将一些独立计算机的整合为一个单一的系统对终端用户提供服务

*   节点:系统中的一个单独角色
*   消息传递:在节点中传递消息
*   目标:所有节点都对系统的状态达成一致 - 达成共识

属性:

*   组件并发工作
*   单个组件有可能失败
*   没有全局锁/全局时序

**共识**
属性:

*   安全: 不会达成错误失误的结果
*   存活: 最终有利的一致性结果会发生

正确性:

*   一致性: 所有非故障节点必须得出一致的结果
*   有效性:决策值必须是节点的输入值
*   有终止:所有非故障节点必须在有限的时间内做出决定

一致性和有效性 达成 安全
有中止达成存活

------------------

**概要**

*   分布式系统
	*   定义 性质
	*   ==CAP定理 #F44336==
*   基于投票的共识
	*   拜占庭将军问题
	*   PBFT共识算法
*   基于凭据的共识
	*   概述
	*   POS

**CAP定理**
一个分布式系统最多只能在如下三个属性中达成两个:

*   一致性:每次获取都会得到最新的值或得到一个错误
*   可用性:每次请求一个非故障节点都可以得到一个响应
*   分区容错:尽管任意数量的消息由于网络问题被丢弃或延迟,系统依然可以继续

![](qiniu.imolili.com/小书匠/1592298707785.png)

**CAP定理的验证**
使用反证法证明:

*   系统运行有 G1和G2两个部分
*   客户端请求将v1写入G1

![](qiniu.imolili.com/小书匠/1592298707678.png)

*   但当请求从G2获取值的时候返回的是v0

![](qiniu.imolili.com/小书匠/1592298707699.png)

译者注:P并认为是通常成立的,因为区间通信失败是通常存在的,而C和A之间的矛盾也是因为P的存在
如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。

综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。

---------------

**概要**

*   分布式系统
	*   定义 性质
	*   CAP定理
*   ==基于投票的共识 #F44336==
	*   拜占庭将军问题
	*   PBFT共识算法
*   基于凭据的共识
	*   概述
	*   POS

**什么是基于投票的共识算法?**
基本思路:

*   该验证网络中的节点应该是已知的并且是可以调节的
*   节点之间通过请求相互通信来进行投票
*   节点要求一定量的投票数来处理请求
*   节点需要能抵制不良的行为 (拜占庭容错)

**拜占庭容错**
故障类别:

*   故障停机:节点有可能崩溃,不再能返回结果
*   拜占庭:节点可以具有任意行为,比如发送不同或者不正确的信息给不同的节点,或者对输入值进行欺骗等等

拜占庭将军的问题:

*   由Lamport,Shostack,Peace 于1982年提出的
*   一个将军给它的副手们下达命令

*   C1:所有忠诚的副手服从相同的命令
*   C2:如果将军自己是忠诚的,那么每个忠诚的副手都会听从它的命令

**无解的情况**
大于或等于1/3叛徒传递口信的方式是无解的
3个将军中有一个叛徒的情况使用反证法:
情况1,一个副将是叛徒
情况2.将军是叛徒副将1会听从命令进行攻击 C2
但是副将2接受到的命令是撤退 这就违反了C1
![](qiniu.imolili.com/小书匠/1592298707717.png)

**拜占庭将军与Blockchain**
![](qiniu.imolili.com/小书匠/1592298707740.png)

-------------------

**概要**
*   分布式系统
	*   定义 性质
	*   CAP定理
*   基于投票的共识
	*   拜占庭将军问题
	*   ==PBFT共识算法 #F44336==
*   基于凭据的共识
	*   概述
	*   POS

**PBFT**
实用拜占庭容错

*   由Castro and Liskov于1999年开发
*   包含 3f+1 的节点和不限数量的客户端.最多可以拥有 f 个拜占庭节点,客户端则无所谓.
*   在异步网络中实现拜占庭容错,达成状态复制

	*   状态复制:节点以相同的顺序执行一个(有可能无限) 系列顺序的命令
	*   一部网络:节点无需访问全局的时序.从一个节点发送到另外一个节点的消息不限时间但最终都会达到.

*   在IBM超级账本系统中的实现

**PBFT:定义**

*   签名 ()ni : 签名保证了每个节点都可以判断消息来自哪一个节点/客户端
*   主备:在任何一个时间,每个节点都会决定选择一个节点作为主节点,而其他作为备份节点
*   View (v) : 主节点的时间跨度
*   序列号 (s) : 主节点使用连续的整数作为序列号标记客户端发送的请求
*   View 变更: 如果备份节点察觉到主节点的故障行为,他们会开始一个新的View

**PBFT:思路**
PBFT的基本思路:

*   客户端向主节点发送请求调用服务
*   预准备阶段:主节点发送预准备消息到各个备节点
*   准备阶段:备节点发送准备消息给所有的节点
*   提交阶段:每个节点都发送提交信息到其他所有节点,在接收到预准备消息并且 2f 个都匹配准备阶段的消息(总共有2f+1个消息) .每个节点在收到 2f+1 个提交的时候执行操作
*   每个节点都在执行完成后发送一个回复给客户端,客户端在收到 f+1个回复后考虑请求完成

PBFT:预准备阶段

*   主节点会通知备节点它想要在 View v中以序列号 s 执行请求 r
*   预准备消息是 pre-prepare(v,s,r,n0)n0

![](qiniu.imolili.com/小书匠/1592298707735.png)

PBFT:准备阶段

*   备节点发送准备ok的消息表明他们同意在View v中使用序列号s执行请求r
*   准备消息是 prepare(v,s,r,ni)ni for i=1,2

![](qiniu.imolili.com/小书匠/1592298707752.png)

PBFT:提交阶段

*   所有节点都通知其他节点,已经在View v中使用序列号s执行了请求
*   提交信息是 commit(v,s,ni)ni for i=0,1,2

![](qiniu.imolili.com/小书匠/1592298707819.png)


**PBFT:为什么数量有 2f+1 和 f+1**

*   在 2f个准备消息匹配预准备消息的时候发送提交消息
	*   2f + 1个消息形成了一个 准备 确认证书
	*   如果一个节点收集到了 (v,s,r) 的准备确认证书就保证了没有节点是收集到了 (v,s,r') 的准备确认(r != r') (为什么? 即处理相同的请求)
*   直接由 2f+1 个提交被接受到后才进行执行
	*   这保证了至少由 f+1个诚实节点收到了 准备的确认证书 (为什么?)
*   客户端需要 f+1个相同结果的回复
	*   这保证了至少由一个诚实节点执行了请求 (为什么?)

----------------------

**概要**

*   分布式系统
	*   定义 性质
	*   CAP定理
*   基于投票的共识
	*   拜占庭将军问题
	*   PBFT共识算法
*   ==基于凭据的共识 #F44336==
	*   概述
	*   POS

**什么是基于凭据的共识?**
基本思路：

*   随机选择一个指挥者 (通过类似的中奖方式)
*   指挥者创建一个新区块并广播给其他人
*   其他投票者通过将区块包含在他们的链中来进行投票

一个身份一票的方式根本不起作用
问题:被消耗的资源是什么?

**基于凭据的共识 1**
POW:工作量证明

*   矿工解决哈希难题
*   防止女巫攻击
*   资源消耗:算力

POS:股权证明

*   通过质押股权来决定谁有可能挖出下一个区块
*   攻击更加昂贵,并且没有动机
*   资源消耗:本币 法币

**基于凭据的共识 2**
POA:活动证明
一种POW和POS的混合共识

*   使用POW来找到新区快
*   使用POS来验证或签名新区快

资源消耗:POW和POS所消耗的资源
POB:燃烧证明

*   发送货币到可以验证的未消费地址
*   燃烧的货币是采矿钻机(译者注:引用自POB算法的发明者伊恩·斯图尔特)
*   资源消耗:货币 代币,即有可能不是本币法币

**基于凭据的共识 3**
POS:空间证明

*   使用磁盘空间来解决问题
*   生成随机的解决方案并存储在硬盘上,能存储更多的值 -> 优势

(译者注:硬盘驱动器越大，可以存储在硬盘驱动器上的解决方案值越多，矿工就越有可能匹配其列表中所需的哈希值，从而有更多机会赢得采矿奖励。)

*   资源消耗:存储空间

PoET:经过时间证明

*   使用可信的执行环境(TEEs),特别是英特尔软件保护扩展(SGX)
*   在选举中通过等待时间来代替算力

	*   每个节点都通过SGX给定一个随机的等待时间
	*   第一个完成等待时间的节点获胜

*   资源消耗:时间

**基于选举的共识VS基于凭据的共识**
![](qiniu.imolili.com/小书匠/1592298707821.png)

------------------------

**概要**

*   分布式系统
	*   定义 性质
	*   CAP定理
*   基于投票的共识
	*   拜占庭将军问题
	*   PBFT共识算法
*   基于凭据的共识
	*   概述
	*   ==POS #F44336==

**POS的各种类型**
基于链的POS

*   从现有的验证者中基于已经质押的股权比例来随机挑选一个验证者
*   选中的验证者创建一个新区块
*   对于一致性来说更有利于可用性

基于拜占庭容错的POS

*   从现有的验证者中基于已经质押的股权比例来随机挑选一个验证者.
*   选中的验证者提议一个新区块,其他验证者对其投票确认是否是一个有效的区块
*   对于可用性来说更有利于一致性

**Casper**
一个基于POS的协议,用以取代现在以太坊中的POW算法
两种Casper版本
Casper the Friendly Finality Gadget (FFG)

*   Vitalik参与的Casper版本
*   是一个混合POW/POS的机制
*   链/BFT混合

Casper the Friendly GHOST (CBC)

*   Vlad版本的Casper
*   使用建构修正（correct-by-construction，CBC）协议
*   真正的POS协议

**Casper FFG**
在现存的POW区块链上的一个基于POS的由确定性的检查点

*   创建检查点(区块高度是100的倍数) (译者注:50?)
*   验证者发送投票信息到公正的检查点
*   只有在其直接子检查点完成的时候,该检查点才会确定完成
*   需要质押,和很苛刻的条件

![](qiniu.imolili.com/小书匠/1592298707995.png)

> 译者注:Casper FFG设计的方式是，一个权益证明协议被叠加在正常的以太坊版工作量证明协议上。虽然区块仍将通过工作量证明来挖出，每50个区块就将有一个权益证明检查点，也就是网络中验证者评估确定性（Finality）的地方。

**Casper CBC**
设计共识协议的第一原则:

*   正确的构建 ( 译者注 : 只是部分的指定协议和协议必须指定的属性)
*   对不同类型数据在共识下提供相同的安全证明
*   Casper the Friendly GHOST

	*   一种 Casper CBC的例子
	*   基于链的POS
	*   最新消息驱动的GHOST,GHOST的改进
	*   最终确定

> 译者注:Friendly GHOST是一个理想的对手（ideal adversary）”的预估安全预言机（estimate safety oracle）这个理想对手要做的事情，就是不断进行微调、让这个只是部分建构好的协议更加完美，直到它变成完全版。

