---
title: IPFS和FileCoin的FIL币
tags: 小书匠语法
renderNumberedHeading: true
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---

[toc]

Protocol Labs旗下的明星项目,每一个都有其独特的定位和功能。我们就来看一看围绕在IPFS和FileCoin周围的几个项目。在Protocol Labs的官网我们可以找到他们，即IPFS、Filecoin、Libp2p、IPLD.

#### IPFS中的libp2p协议

Libp2p是一个模块化的网络栈，通过将各种传输和P2P协议结合在一起，使得开发人员很容易构建大型、健壮的P2P网络。下面给出了Libp2p项目的官网和开源代码 [libp2p.io](https://libp2p.io/)

Libp2p被用作IPFS的网络层，主要负责发现节点、连接节点、发现数据、传输数据。

Libp2p 集成了各种传输协议和点对点协议，其主要作用是发现节点和内容，并且让不同的网络协议能够互相之间顺利的传送数据。开发人员可以使用 Libp2p 轻松构建大型，稳定的 p2p 网络。Libp2p 主要包含了如下技术实现：

- Transports：传输
- Discovery：发现
- Peer Routing: 节点路由
- NAT Traversal: NAT穿透
- Content Routing: 内容路由

##### Libp2p的架构

*   ==Peer Routing - 节点路由==
    用来决定使用哪些节点来路由指定的消息。这种路由机制可以递归甚至在广播/组播模式下完成。
	
*   ==Swarm - 连接处理==
    负责管理节点之间连接的创建、维护、销毁。包括协议多路复用、流多路复用、NAT穿透和连接中继，同时进行多路传输。
	
*   ==Distributed Record Store - 分布式记录存储==
    存储和分发记录的系统，负责记录节点相关的各种信息，便于连接管理和内容寻址。
	
*   ==Discovery - 发现==
    发现和识别网络中的其他节点。

##### Libp2p的流程

-  运行 Libp2p 协议的节点在初始化之后需要通过各种方式发现更多的节点，比如Bootstrap list、mDNS、DHT 等，这主要由 **Discovery（发现）模块**负责与实现。
-  Libp2p 会把这些获取到的节点信息存储在**分布式记录存储模块**中，供以后方便使用。
-  当上层应用需要连接某个节点时，**节点路由模块**会找到多条不同的路径，**连接管理模块**会对这些路径进行尝试连接。（由于P2P网络本身的特性，节点之间的连接状况始终在动态变化，故不是所有路径都是可以成功连接的～）
-  连接成功之后，上层应用将通过 Libp2p 与连接节点进行交互，互相传递数据 。

下面具体分析一下连接过程的主要步骤

**地址解析**

为了适应复杂的网络环境，libp2p 支持多种不同的底层协议，甚至 IPFS 社区专门立了一个项目来标准化节点的地址[multiaddr](https://github.com/multiformats/multiaddr)。目前 libp2p 主要支持以下几种地址格式：

*   `/ip4/127.0.0.1/tcp/4001/ipfs/QmNodeID`: 这种格式跟传统的 TCP 网络里是一样的，直接可以解析出对应的 IPv4 地址和端口号；
*   `/ipfs/QmNodeID`: 这种格式的地址适用于 IPFS 网络，只有节点ID的地址，需要节点路由模块找到节点对应的IP地址，然后再进行连接；
*   `/dns4/http://ipfs.ipfsbit.com/tcp/443/wss/p2p-webrtc-star`: 这种地址需要调用`multiaddr-dns`组件，把域名解析成IP地址，然后再进行连接；
*   `/p2p-circuit/p2p/QmNodeID`: 这种地址是relay地址，用于中继网络，需要首先连接一个中继节点，才能连接到目的节点；

通过地址解析，libp2p能获知如何才能连接到目的节点，下一步就是尝试建立连接。

**传输协议分配**

地址里面的`/tcp`、`/quic`、`/ws`、`/p2p`分别对应不同的传输协议实现。libp2p 定义了统一的,选择地址对应的传输协议，调用传输协议的连接函数尝试连接目的节点。

**双方协商**

连接建立之后，libp2p 会首先进行双方协商，确定对方支持哪些功能。负责协商功能的是identify协议，它是内置在 libp2p 的基础协议，能够交换节点的公钥、本地监听地址等。
协商完成后，连接两端的节点会找到共同支持的协议，并且初始化它们。初始化时会注册每种协议的handler（回调函数），当有协议数据到达时，相应的handler就会被调用。由于多种传输协议会复用同一个底层连接，所以连接会被拆分成多个“流（Stream）”。

Libp2p 可以通俗理解成适用于多种传输协议的P2P网络层。由于目前网络模式多种多样，比如4G 网络/宽带网络，拨号/固定公网IP，以及还有着各式各样的传输协议（TCP、UDP等等）和网络防火墙的通信阻碍，所以导致这个协议的实现是非常复杂的。

##### 关于NAT遍历的特殊说明

1. automatic route configuration

许多路由器支持端口转发的自动配置协议，最常见的是 `upnp` 和 `nat-pmp`。

如果路由器支持这些协议之一，则libp2p将尝试自动配置端口映射，以使其能够侦听传入的流量。如果网络和libp2p实现支持，这通常是最简单的选项。

2. stun

在内部机器拨号建立了到公网地址的连接时,海可以接收到在公网地址端口上的传入连接,并会路由到内部计算机的内部IP.但遗憾的是,内部计算机并不会自行发现公网地址上分配给他们连接的端口

但是,外部的对等节点可以告诉他们观察到的地址,并进行广播,让对等网络知道在哪里可以找到这些内部节点.

当使用IP支持的传输的时候,libp2p会尝试使用套接字选项通过相同的端口来继续宁传输.

这种外部发现机制的作用和 STUN相同,但并不需要一组 STUN服务器.

3. AutoNAT

上面描述的方式可以使 peer之间相互通知自己观察到的网络地址,但并非所有网络都允许在拨出的公网地址上的同一端口接受传入连接.

那么其他 peer可以帮助我们察觉到这个处境,他们可以通过我们自己连接到的对等地址来连接我们

4. TURN

当然也有可能 peer完全无法以nat的方式获得可公开访问的途径,libp2p提供了 TURN使得 peer之间通过一个中间对等节点来相互通信.

这就是 `Circuit relay`,它可以让两个 peer通过一个第三方的继电器peer相互通信.

中继协议是非透明的,即通信双方可以看到这个中继地址

中继协议仅在peers双方都可以发现并愿意对两端访问进行中继中继对等peer才有效.

##### 关于多路复用的特殊说明

libp2p中的多路复用和tcp/ip使用端口号来多路复用不同.他是在应用层实现的,这意味着它不是操作系统的网络堆栈来提供的功能.

libp2p中一般是在初始配置中对这一模块进行启用的配置,然后在 switch (或者称为swarm取决于实现) 的组件中维护有关已知对等项和连接的状态的. switch提供了 dial和listen的接口可以用来处理流的多路复用.

----------------

#### IPLD

IPLD是内容寻址的数据模型,即 merkle dag的组装数据结构.

- schema layer
- data model layer
- block layer

**block layer (layer 0)**
仅此一层就可以描述很多格式的的基本数据,但是并没有定义数据结构或者数据类型,可以使用不同的编码器编码到不同的类型.

类似于字符的编码,只是十六进制编码,但是存储格式并不确定,只是说明了某种类型的数据应该有的基本数据,但并没有规定如何组织数据结构和如何存储(类如json?binary?之类的定义).

比如一个区块可以用 cid,编码器和一个 hash-value 加上二进制数据来表示.

**data model layer (layer 1)**

这一层是由IPLD编码器来实现的基本必须要的数据类型.

基本类型
*   Null
*   Boolean
*   Integer
*   Float
*   String
*   Bytes
*   List
*   Map
*   Link

循环类型
*   List
*   Map

可以用在循环类型T中的类型
*   Null
*   Boolean
*   Integer
*   Float
*   String
*   Bytes
*   Link

**schema layer**
架构曾定义了从数据模型层到包含了复杂数据结构的映射.

* Set
* List
* Queue
* Stack
* SortedSet
* Map
* ListMap
* SortedMap

----------------

#### IPFS

- IPLD:将数据import到ipfs中的协议族
- Bitswap:拉取和传输数据区块的协议
- CID v0:使用Qm开头的cid
- CID v1:包含了一只前缀来标识可以向后兼容的cid version.
- DHT:A Distributed Hash Table (DHT) 分布式的key-value存储.
- Gateway:ipfs网络在http上的代理接入点
- multihash中被hash的数据是通过multicodec组织的数据
- multihash是一个自描述hash算法后的数据

**CID字符串的组成**
```
cid-version有两种

cid v0是 Qm开头的 只有multihash
看起来是这样的
<0><dag-pb><multihash>
当使用cid v0的时候都是固定使用base58的

cid v1是 一串00000001的version数据看起来像这样
Binary:
<cid-version><ipld-format><multihash>
String:
<base>base(<cid-version><ipld-format><multihash>)
ipld-format是定义好的不是 magic-number 的常量
```

当使用cid v1的时候如果第一个字符是 b表示base32,z表示base58btc,f表示base16

这个base字符叫做 multibase table [multibase](https://github.com/multiformats/multibase)

可以使用这个工具进行分析 [cid.ipfs.io](https://cid.ipfs.io)

**将文件加入到ipfs**

首先会对要加入的文件内容进行 chunk 分块,并组成dag的形式

然后从叶子节点开始一层一层往上计算cid直到最终的根节点

可以使用这个工具进行分析 [dag.ipfs.io](https://dag.ipfs.io/)

平均分割法和smart变长分割法(rabin方式);
rabin方式会使用16byte的滑动窗口来计算,使得块大小分布在一个平均值形成正太分布,
这样可以使得内容的修改仅仅知会影响修改的块

==UnixFS==

Node+ \[UnixFS File] + C1

**客户端**

使用 go-ipfs 的cli或者是 ipfs-desktop 的 windows客户端都可以;
使用 ipfs-update进行更新,或者在更新了程序后使用 `ipfs daemon`进行数据升级迁移.

**IPNS和DNSLink**
IPNS是使用 `ipfs name pushlish CID`来创建一个对特定内容 ipfs-path 的指向;
DNSLink是直接使用dns的txt记录来实现的.即将对一个域名的访问,改为 dnslink=/ipfs/Cid 的访问;

`my-dns-tool set --type=TXT --ttl=60 --domain=libp2p.io --name=_dnslink --value="dnslink=/ipfs/Qmc2o4ZNtbinEmRF9UGouBYTuiHbtCSShMFRbBY5ZiZDmU"`

----------------

#### FileCoin Quick View

IPFS是一个协议
现在的挖矿是指FileCoin上的挖FIL币

>矿机选择  灵动、先河、原力、1457 蚂蚁 星际
矿机的硬件要素需求 磁盘 显卡 CPU RAM
矿机厂商更多的是对硬件资源的整合
IPFS的Filecoin挖矿技术成本很低,主要是官方提高了硬件成本
静态IP 对等带宽 8core+ 32g扇区 128gRam最少 ssdCache 热插拔设计

从硬件要求上看,各个矿机供应商大同小异
但是硬件配置其实只占了挖矿收益影响因素约30%的比重，主要影响因素还是各厂家的软件与运维上。

主网上线后算力大涨，每T内存的产币量会同步缩减,自建矿机的成本问题
当前FIL币价非常高,比年初要涨了将近7-8倍
卖矿机相当于卖矿机使用权,同时还有FIL的托管费用(25%)

针对不同的角色所需求的硬件能力是不一样的
对于旨在存储数据作为仓储节点的话主要是需要硬盘和打包速度

如果还需要作为一个检索服务的节点的话,那么高性能的带宽传输能力也是必须的

挖矿的主要操作

1. 密封预交付阶段1 PoRep（复制证明）几个小时
PoRep SDR编码,此阶段受CPU限制,并且是单线程的,故需要强性能的CPU,SHA扩展的==AMD处理器==在很大程度上加快了此过程

2. 密封预交付阶段2 波塞冬（Poseidon)哈希算法执行Merkle树生成 几十分钟
GPU

3. 密封提交阶段1 几十秒
执行生成证明所必需的准备工作的中间阶段 CPU运算

4. 该密封阶段涉及创建SNARK 将证明在广播之前进行压缩, 30分钟
GPU密集型

集群化的部署???
经过测试其中若干步骤发生在相同的机器上更好,因为需要大量数据的传输

质押包括质押扇区的规模和存储矿工存放的抵押币
1Sector 1Filecoin=32GB -> 1pb=10^6G/32G=31250Fil
也就是说，1PB要3万个Fil质押进去，如果10PB就要质押进去30万个，主网上线第一天全球挖出来的币是41.8万个

综上所述,目前filecoin的机制设定和硬件要求,就是完完全全的阻碍个人挖矿者的,必须采取大容量矿池的方式进入

-------------------

#### Fileoin的基础术语

- **客户**:客户付费存储和检索数据。他们可以从可用的存储服务商中进行选择。如果他们想存储私有数据，则需要在将其提交给存储服务商之前对其进行加密。
- **存储矿工**:存储矿工存储客户的数据以获得奖励。他们决定愿意保留多少空间来存储。在客户和存储矿工达成协议后，矿工有义务继续提供其存储数据的证据。每个人都可以查看证据，并确保存储矿工可信。
- **检索矿工**:检索矿工根据他们的要求提供客户的数据。他们可以从客户或存储矿工那里获取数据。检索矿工和客户支付很少的费用来交换数据：数据被分成几部分，客户每片段支付很少费用。检索矿工也可以充当存储矿工。
- **片段**:片段是客户端存储在分散存储网络中的数据的一部分。例如，可以将数据（可能是一个目录）有意地分为许多部分，并且每个部分可以由一组不同的存储矿工存储。
- **扇区**:扇区是存储矿工提供给网络的一些磁盘空间（可以认为是与特定存储提供者的磁盘空间的特定部分相关联的唯一ID）。矿工将客户的物品存放在其所在的区域，并为其服务赚取代币。为了存储片段，存储矿工必须向网络保证其扇区可用。
- **订单和订单簿**:订单是请求或提供服务的意图声明。客户向市场提交标的订单以请求服务（分别是用于存储数据的存储市场和用于获取数据的检索市场），而矿工则接受订单以提供服务。订单簿是订单的集合。Filecoin为存储市场和检索市场维护独立的订单簿。
- **承诺aka质押**:承诺是向网络提供存储（特别是扇区）的承诺。存储矿工必须向账本（文件币区块链）提交质押才能开始在存储市场中接受订单。质押包括质押扇区的规模和存储矿工存放的抵押币。

- **存储挖矿**:存储矿工的作用是代表Filecoin网络保存文件。存储矿工必须以加密方式证明他们兑现了存储这些文件的承诺–这是通过复制证明（PoRep）和时空证明（PoSt）机制实现的。将存储抵押到Filecoin网络本身需要Filecoin。这些被用作担保，以确保存储矿工履行其合同义务。

- **储存资料**:在Filecoin网络中，数据存储在固定大小的扇区中。通常，存储矿工用代表客户存储的数据填充这些部门，客户通过交易在特定时间段内与存储矿工服务签约。但是，存储矿工并没有被迫进行交易。如果存储矿工没有找到任何有吸引力的交易建议，他们可以选择做出容量承诺，用任意数据填充部门。这使他们可以证明他们正在代表网络保留空间。如果需要，以后可以“升级”为充当容量承诺而创建的部门，以便为将来的交易提供合同存储空间。

- **复制证明**:一旦该扇区已被填充，PoRep看到存储矿工密封 扇区-密封是计算密集的过程的结果在所述数据的唯一表示（原始表示随后可以通过重构开封）。一旦数据被密封，存储矿工：生成证明；对证明运行SNARK进行压缩；最后，将压缩结果提交给区块链，作为存储承诺的证明。通过此过程为网络保留的存储称为抵押存储。

- **时空证明**:PoRep完成后，存储矿工必须不断证明他们仍在存储他们承诺存储的数据。这是通过PoSt完成的，PoSt是向存储矿工发出加密挑战的过程，只有直接咨询密封部门才能正确回答。存储矿工必须在严格的时间限制内应对这一挑战；密封的计算难度确保了存储矿工必须保持对密封部门的随时访问和完整性。

- **WindowPost**:WindowPoSt是一种机制，可用来审核存储矿工的承诺。它看到每个24小时周期分解为一系列窗口。相应地，每个存储矿工的保证扇区集都被划分为子集，每个窗口一个子集。在给定的窗口内，每个存储矿工必须为其各自子集中的每个扇区提交PoSt。这要求可以立即访问每个面临挑战的部门，并将导致将SNARK压缩的证据作为消息以块形式发布到区块链。这样，在每个24小时内至少对一次保证存储的每个部门进行一次审核，并保留一个永久，可验证的公共记录，以证明每个存储矿工的持续承诺。Filecoin网络期望存储文件的持续可用性。未按规定提交WindowPoSt的部门将导致 故障，存储矿工提供的部门将被削减 -也就是说，他们的抵押品的一部分将被没收，他们的蓄电量（见蓄能，下同）将看到一个减少。在被认为完全放弃存储承诺之前，存储矿工将有有限的时间从故障中恢复。如果需要，存储矿工也将具有先发制人的过错的能力，这将减少处罚，但仍必须在合理的时间内解决。

- **WinningPost**:WinningPoSt是一种机制，通过这种机制可以奖励存储矿工的贡献。在Filecoin网络中，时间离散化为一系列时期-区块链的高度对应于经过的时期数。在每个时间点开始处，存储的矿工的少数当选到矿井新块（Filecoin利用 tipsets，其允许多个块而在相同的高度被开采）。每个成功创建区块的当选矿工都将获得Filecoin，并有机会向其他节点收取费用以在区块中包含消息。存储矿工的当选概率与其存储能力相对应。在与基础WindowPoSt相似的过程中，存储矿工的任务是在纪元结束之前提交指定扇区的压缩存储证明。未能在必要的窗口中完成WinningPoSt的存储矿工将丧失开采区块的机会，但不会因未能这样做而受到处罚。

- **存储能力**:Filecoin存储矿工的能力与选择存储矿工开采区块的可能性相对应，与他们代表网络密封的存储量大致成比例。为了通过简单的容量承诺进一步激励“有用”数据的存储，存储矿工有额外的机会竞争经过验证的客户提供的特殊交易。此类客户在提供涉及存储有意义数据的交易意图方面获得了认证，并且存储矿工为这些交易赚取的权力将通过乘数得到增强。考虑到该乘数后，给定存储矿工拥有的总电量称为质量调整后的 电量。

- **存储市场**:

客户向存储订单簿提交一个投标订单（使用PUT协议，在下一节中说明）。客户必须存放订单中指定的费用并指定他们要存储的副本数量。客户可以提交多个订单，也可以在订单中指定复制因子。更高的冗余度（更高的复制因子）导致对存储故障的更高容错率（如下所述）。

Manage.PledgeSector
存储矿工通过通过==Manage.PledgeSector==在区块链中通过质押交易存入抵押品来保证其对网络的存储。抵押品（Fil）在提供服务的时间内存放，如果矿工为其承诺存储的数据生成存储凭证，则将其退还。如果某些存储证明丢失，则会损失一定比例的抵押品。一旦质押交易出现在区块链中，矿工就可以在存储市场中提供其存储服务：他们设置价格并将要价单添加到市场的订单簿中。

Put.AddOrders
一旦质押交易出现在区块链中（在AllocTable中），矿工便可以在存储市场中提供其存储服务：他们设置价格并通过==Put.AddOrders==将要价订单添加到市场的订单簿中。

Put.MatchOrders
当找到匹配的要价和买价单时（通过==Put.MatchOrders==），客户将片段（数据）发送给矿工。

Put.ReceivePiece
当接收到片段，矿工运行==Put.ReceivePiece==。接收到数据后，矿工和客户都签署了交易订单并将其提交到区块链（在存储市场订单中）

Manage.AssignOrders
存储矿工的存储分为多个扇区，每个扇区包含分配给矿工的部分。网络通过分配表跟踪每个存储矿工的扇区。此时（签署交易订单时），网络会将数据分配给矿工，并在分配表中记录下来。

Manage.SealSector
当存储矿工扇区被填充时，该扇区被密封。密封是一种缓慢的顺序操作，它将扇区中的数据转换为副本，该副本是与存储矿工公钥关联的数据唯一物理副本。在复制证明期间，密封是必要的操作。

Manage.ProveSector
当为存储矿工分配数据时，他们必须反复生成复制证明以确保他们正在存储数据,证明会发布在区块链上，网络会对其进行验证。

如果缺少任何证据或证据无效，则网络会通过存储矿工的抵押币对他们进行惩罚。
如果大量证据缺失或无效（由系统参数Δfault定义），则网络会认为存储矿工有故障，将订单结算为失败，然后相同新订单重新引入市场。
如果每个存储该矿工的都无法存储该片段，则该片段将丢失，并且客户将获得退款。

- **检索市场**:
这是一个脱链交换，客户和检索矿工以对等方式彼此发现。一旦客户和矿工就价格达成协议，他们便开始使用小额付款逐笔交换数据和币。

Get.AddOrders
检索矿工通过在网络上散播他们的要价单：他们设置价格并将要价单添加到市场的订单簿中。

Get.MatchOrders
客户向投标市场订单簿提交投标订单。检索矿工检查其订单是否与客户的相应投标订单相匹配。

Put.SendPiece
订单匹配后，检索矿工将件发送给客户（矿工发送部分数据，客户发送小额付款）。收到件后，矿工和客户都签署了交易订单并将其提交给区块链。

![](https://raw.githubusercontent.com/OliverRen/olili_blog_img/master/IPFS和FileCoin的FIL币/2020831/1598855520528.png)

-----------

#### 一般硬件问题

虽然我们无法提供具体建议，但可以提供一些一般性指导。

**CPU** 根据经验，具有高时钟频率的多核CPU将加速密封过程，使存储矿工可以更快地将存储到网络上。Protocol Labs自己的测试表明，具有SHA扩展功能的现代AMD处理器具有 比其他处理器更大的优势。

**GPU** 必须有强大的GPU，才能在所需的时间限制内完成SNARK计算。Lotus当前被设计为支持NVIDIA制造的芯片。我们预计将来还会有其他制造商的支持卡。我们的 基准测试 可帮助您深入了解成功的芯片。

**RAM** 当前的Filecoin网络仅支持密封32GiB和64GiB扇区。在这些较大的扇区上执行必要的计算需要相应的更多RAM。建议采矿系统至少配备128GiB。

**存储** 选择合适的存储解决方案涉及很多考虑因素，也许最重要的是采矿作业所采用的特定收益模型。存储矿工目前需要保证原始存储量为1TiB（或质量调整后的等同量；对于主网，它将增加到100TiB），以便开采区块，但是超出此要求的因素还有很多，他们可能会觉得有用考虑。

*   首先，存储矿工应该牢记数据丢失的严厉处罚；即使翻转一位也可能导致严厉的处罚。结果，存储矿工可能希望考虑开销以实现数据冗余。
*   对于试图加入检索市场的存储矿工来说，考虑合并其他存储以准备提供密封数据的“热”副本也可能是明智的。尽管当然可以打开一个扇区以恢复原始数据，但是支持此用例的Filecoin实现将消除这种计算负担（这是Lotus当前正在开发的功能）。
*   要考虑的另一个考虑因素是Filecoin网络对高可用性的期望。虽然理论上存储矿工应该能够与大多数商品的硬盘，固态硬盘，或其他合适的，非冷存储解决方案，不是所有的存储解决方案可依靠操作时执行最佳参加24 / 7。
*   当前，存储矿工还需要足够的空间来存储区块链本身。减少磁盘上区块链的占用空间是Lotus积极开发的一项功能。Filecoin的实现可能还需要额外的磁盘存储，以用于簿记，相当于已抵押存储的一小部分。
*   最后，协议实验室在测试中发现，将NVMe存储用作交换空间 可以在具有较少RAM（128GiB）数量的系统中用作补充。否则，存储矿工在某些操作期间可能会遇到内存不足的问题（尤其是密封需要大量工作内存）。

**网络** 如果使用分布式Lotus Seal工作人员（请参阅 下面的“ 高级挖掘注意事项”），则建议使用高性能网络（建议使用10GbE +网卡和交换机）。使用网络附加存储时，还建议使用高性能网络。

**先进的采矿注意事项**

如前所述，Filecoin存储挖掘主要由与PoRep和PoSt机制相关的担忧所主导。PoRep本身是由几个阶段和Lotus实施Filecoin的便于这些阶段不同的机器代表团使用效率最大化密封工人。Protocol Labs开发了一个示例架构，旨在利用这些功能进行大规模挖掘。在这里，我们分解了设计类似系统时要考虑的不同瓶颈。

- 密封预交付阶段1

在此阶段，进行PoRep SDR编码。此阶段受CPU限制，并且是单线程的（根据设计，它不适合并行化）。该阶段预计需要几个小时的时间，确切的时间取决于要密封的扇形的大小，当然还取决于进行密封的机器的规格。如前所述，Protocol Labs（及其他）发现，具有SHA扩展的AMD处理器在很大程度上加快了此过程。使用时钟频率更高的CPU也会提高性能。

- 密封预交付阶段2

在此阶段，使用波塞冬(Poseidon)哈希算法执行Merkle树生成。此过程主要是受GPU限制的-可以将CPU用作替代方案，但应该会慢得多。使用GPU时，此阶段预计需要45分钟到一个小时。

- 密封提交阶段1

这是执行生成证明所必需的准备工作的中间阶段。它受CPU限制，通常在数十秒内完成。

- 密封提交阶段2

最后，该密封阶段涉及创建SNARK，该SNARK用于在将必需的证明广播到区块链之前对其进行压缩。这是一个GPU密集型过程，预计需要20到30分钟才能完成。

协议实验室发现将preCommit阶段2，提交阶段1和提交阶段2并置在同一台计算机上是有效的，利用高密度计算机进行preCommit阶段1。但是，preCommit阶段1之间存在大量文件传输以及交付前阶段2；在网络访问速度较慢或使用硬盘而不是固态驱动器的计算机上，这可能会超过其他方面的性能提升。在这种情况下，让所有阶段都出现在同一台机器上可能会更有效率。

PoSt主要受GPU约束，但可以利用具有许多内核的CPU来加速过程。例如，WindowPoSt当前必须在30分钟的窗口内进行；24核CPU和8核CPU之间的差异可能是在以适当的余量清除该窗口与在狭窄的时间范围内进行清除之间的差异。WinningPoSt是一种强度较低的计算，必须在Filecoin时期的较小窗口（当前为25秒）内完成。

----------------

#### FileCoin的经济模型

**代币释放模型**

Filecoin 代币总量为 20 亿枚,
5％分配给 Filecoin 基金会，
10% 用于融资，
15% 分配给协议实验室，
70% 分配给矿工。其中代币总量的 15%, 3亿枚，将被用作为挖矿储备金，以在未来激励检索矿工和其他类型的矿工，具体使用方式以后由社区通过 Filecoin 改进提案（FIP）共同决定。

**质押**

为了减轻矿工的负担至最低来满足对质押的多种需求，Filecoin有三种不同的质押机制：

- 存储质押：7天的扇区故障费和1个扇区故障检测费（和区块奖励大小挂钩）
- 共识质押:  为了实现30%的网络流通量都要被锁定在初始共识质押中。 所以需根据扇区加权字节算力(QAP), 在网络中所占的比例分配给该扇区一小部分质押份额, 初始质押应随时间的减少而减少
- 区块奖励质押：挖到币后先锁仓20天，后180天线性释放。意思就是20天后就能每天平均地拿到挖到的币，180天拿完。因为矿工是一致在挖币的， 所以只需要等待第一个20天， 后面每天都会受到奖励。

其中1+2目前是一个扇区1个FIL.只是极限值,未来只少不多.

**产币**

- 简单产币:6年减半的那种。这部分占每天释放币的30%。
- 基准产币：总网络达到某一个算力基准时， 才释放币。这个基准一开始为1EB（相当于1000PB)，然后每年增加200%，之后5年分别是： 3EB，9EB, 27EB, 81EB，243EB。。。全网算力一旦到了这个基准线，就继续释放剩余的奖励币， 这部分占70%。

第一阶段：收入以“简单产币”为主，因为全网还没到1EB, 所以30%的币是一挖就有，另外70%得到了基准线后才有。

第二阶段：到了网络基准线了， 这时候整个网络容量很大，可以存很多有用的数据， 我们也能挖到那额外的70%的“基准产币”了，除此之外还会有一部分的存储订单交易收入。

第三阶段：挖币的人越来越多， 区块奖励越来越少，“简单产币”基本上没了， 这就和比特币一样，那么主要收入来源于提供高质量存储和检索服务和交易手续费了

矿工应在以下3方面努力来挖到更多币：

- 性能更高的复制证明算法：链上数据更少、验证时间更快、硬件成本更低、不同的安全性假设，从而使扇区生命周期更长，并且无需重新封装即可进行扇区升级。

- 更具可扩展性的共识算法，可以提供更大的吞吐量并以更短的时间内处理更多的消 息。

- 更多可以使扇区持续更长的时间的交易订单功能。

![](https://raw.githubusercontent.com/OliverRen/olili_blog_img/master/IPFS和FileCoin的FIL币/2020831/1598861682918.png)