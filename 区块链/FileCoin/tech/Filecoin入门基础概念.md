---
title: Filecoin入门基础概念
tags: 小书匠语法
renderNumberedHeading: true
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---

[toc]

#### 推荐的学习路径文档列表

1. FileCoin官方文档 [docs.Filecoin.io](https://docs.Filecoin.io/) ps官方的文档有可能一天都改动好多,看的时候多多刷新
2. [术语表](https://docs.Filecoin.io/reference/glossary)
3. FileCoin官方说明书 [spec.Filecoin.io](https://spec.Filecoin.io/)
4. Go-Filecoin的code review [github go-Filecoin code review](https://github.com/Filecoin-project/go-Filecoin/blob/master/CODEWALK.md)
5. 推荐的客户端工具Lotus [lotus.sh](https://lotu.sh/) , [lotus.github源码](https://github.com/Filecoin-project/lotus)
6. 关于Filecoin的存储证明教学 [proto_school](https://proto.school/tutorials) ,[proto school-verifying storage on Filecoin](https://proto.school/verifying-storage-on-Filecoin/)	

#### Fileoin的基础术语

- **Block和Epoch** </br>
	FileCoin 区块链中的 epoch 是离散为25秒的一个时期,每个 epoch 中,都会选择存储矿工的一个子集,这个子集会通过 Winning-of-Spacetime 来向 Filecoin 添加一个block区块.这个选择被称为选举,一个矿工当选的可能性大致与他们贡献的网络总存储容量占整个 Filecoin 网络的份额成正比.这些矿工提交的区块 block 一起构成了一个 tipset .
- **客户** </br>
	客户付费存储和检索数据.他们可以从可用的存储服务商中进行选择.如果他们想存储私有数据,则需要在将其提交给存储服务商之前对其进行加密.
- **存储矿工** </br>
	存储矿工存储客户的数据以获得奖励.他们决定愿意保留多少空间来存储.在客户和存储矿工达成协议后,矿工有义务继续提供其存储数据的证据.每个人都可以查看证据,并确保存储矿工可信.
- **检索矿工** </br>
	检索矿工根据他们的要求提供客户的数据.他们可以从客户或存储矿工那里获取数据.检索矿工和客户支付很少的费用来交换数据,数据被分成几部分,客户每片段支付很少费用.检索矿工也可以充当存储矿工.
- **片段** </br>
	片段是客户端存储在分散存储网络中的数据的一部分.例如,可以将数据(可能是一个目录)有意地分为许多部分,并且每个部分可以由一组不同的存储矿工存储.这主要取决于矿工采矿采用的sector大小,如32GB或64GB
- **扇区(Sector)** </br>
	扇区是存储矿工提供给网络的一些磁盘空间(可以认为是与特定存储提供者的磁盘空间的特定部分相关联的唯一ID).矿工将客户的物品存放在其所在的区域,并为其服务赚取代币.为了存储片段,存储矿工必须向网络保证其扇区可用.目前sector的大小有32GB和64GB两种.
- **订单和订单簿** </br>
	订单是请求或提供服务的意图声明.客户向市场提交标的订单以请求服务(分别是用于存储数据的存储市场和用于获取数据的检索市场),而矿工则接受订单以提供服务.订单簿是订单的集合. Filecoin 为存储市场和检索市场维护独立的订单簿.
- **承诺aka质押** </br>
	承诺是向网络提供存储(特别是扇区)的承诺.存储矿工必须向 Filecoin 区块链提交质押才能开始在存储市场中接受订单.质押包括质押扇区的规模和存储矿工存放的抵押币.
- **消减(Slash)** </br>
	当某个扇区出现故障的时候,Filecoin 网络会大幅减少本应该存储这个 sector 的存储矿工.并且会减去该矿工的总算力.
- **密封(Seal)** </br>
	密封是 Filecoin 协议的基本构建块之一.这是在一个扇区上执行的计算密集型过程,导致该扇区的唯一表示.这种新表示的性质是基本验证的复制的和验证的时空过程.
- **存储挖矿** </br>
	存储矿工的作用是代表 Filecoin 网络保存文件.存储矿工必须以加密方式证明他们兑现了存储这些文件的承诺–这是通过复制证明(PoRep)和时空证明(PoSt)机制实现的.将存储抵押到 Filecoin 网络本身需要 Filecoin .这些被用作担保,以确保存储矿工履行其合同义务.
- **储存资料** </br>
	在 Filecoin 网络中,数据存储在固定大小的扇区中.通常,存储矿工用代表客户存储的数据填充这些部门,客户通过交易在特定时间段内与存储矿工服务签约.但是,存储矿工并没有被迫进行交易.如果存储矿工没有找到任何有吸引力的交易建议,他们可以选择做出容量承诺,用任意数据填充部门.这使他们可以证明他们正在代表网络保留空间.如果需要,以后可以“升级”为充当容量承诺而创建的部门,以便为将来的交易提供合同存储空间.
- **非交互性零知识证明(zk-SNARK)** </br>
	验证者和证明者之间不需要进行交互,而仅仅只需要持有相对应随机数不同的hash值即可判定证明者的确证明了对应的事物.这里就需要证明者自证即为 WindowsPost
- **存储证明Proof-of-Storage** </br>

	许多区块链网络都以参与者为区块链提供某种价值这一观念为基础-这种贡献很难伪造,但如果确实做出了,则可以进行微不足道的验证.通常认为基于这种方法的区块链需要“ X证明”,其中X是有价值的贡献.Filecoin区块链重视存储容量的贡献；它以新颖的存储证明构造为基础,将其与其他区块链区分开来,而其他区块链在大多数情况下需要贡献计算能力.

	术语,存储证明是指Filecoin协议的设计元素,它使一个人可以保证(达到很高的容忍度)声称声称贡献了给定存储量的参与者确实履行了这一承诺.实际上,Filecoin的存储证明结构提供了更为强大的主张,使人们可以有效地验证参与者是否正在存储特定的数据,而无需一个人自己拥有文件的副本.

	注意 : 这里的“证明”是非正式的用法-通常,这些证明采取概率论证的形式,而不是具体的证明；也就是说,从技术上讲,可以说服其他参与者,一个人没有做出贡献,但是这种可能性微乎其微,几乎不可能
	
	PS : 存储证明是一个泛化的概念,挖矿软件的实际工作是下面的复制证明和时空证明.
- **复制证明Proof-of-Replication(PoRep)** </br>
	一旦该扇区已被填充,PoRep看到存储矿工密封 扇区-密封是计算密集的过程的结果在所述数据的唯一表示(原始表示随后可以通过重构开封).一旦数据被密封,存储矿工 : 生成证明；对证明运行SNARK进行压缩；最后,将压缩结果提交给区块链,作为存储承诺的证明.通过此过程为网络保留的存储称为抵押存储.
- **时空证明Proof-of-Spacetime(PoSt)** </br>
	PoRep完成后,存储矿工必须不断证明他们仍在存储他们承诺存储的数据.这是通过PoSt完成的,PoSt是向存储矿工发出加密挑战的过程,只有直接咨询密封部门才能正确回答.存储矿工必须在严格的时间限制内应对这一挑战；密封的计算难度确保了存储矿工必须保持对密封部门的随时访问和完整性.
- **窗口时空证明(WindowPost)** </br>
	WindowPoSt是一种机制,可用来审核存储矿工的承诺.它看到每个24小时周期分解为一系列窗口.相应地,每个存储矿工的保证扇区集都被划分为子集,每个窗口一个子集.在给定的窗口内,每个存储矿工必须为其各自子集中的每个扇区提交PoSt.这要求可以立即访问每个面临挑战的部门,并将导致将SNARK压缩的证据作为消息以块形式发布到区块链.这样,在每个24小时内至少对一次保证存储的每个sector进行一次审核,并保留一个永久,可验证的公共记录,以证明每个存储矿工的持续承诺.Filecoin网络期望存储文件的持续可用性.未按规定提交WindowPoSt的Sector将导致故障,存储矿工提供的Sector将被削减 -也就是说,他们的抵押品的一部分将被没收,他们的总算力将看到一个减少.在被认为完全放弃存储承诺之前,存储矿工将有有限的时间从故障中恢复.如果需要,存储矿工也将具有先提交有过错的能力,这将减少处罚,但仍必须在合理的时间内解决.
- **赢得时空证明(WinningPost)** </br>
	WinningPoSt是一种机制,通过这种机制可以奖励存储矿工的贡献.在Filecoin网络中,时间离散化为一系列时期-区块链的高度对应于经过的时期数.在每个时间点开始处,存储的矿工的少数当选到矿井新块(Filecoin利用 tipsets,其允许多个块而在相同的高度被开采).每个成功创建区块的当选矿工都将获得Filecoin,并有机会向其他节点收取费用以在区块中包含消息.存储矿工的当选概率与其存储能力相对应.在与基础WindowPoSt相似的过程中,存储矿工的任务是在epoch结束之前提交指定扇区的压缩存储证明.未能在必要的窗口中完成WinningPoSt的存储矿工将丧失开采区块的机会,但不会因未能这样做而受到处罚.
- **存储能力** </br>
	Filecoin存储矿工的能力与选择存储矿工开采区块的可能性相对应,与他们代表网络密封的存储量大致成比例.为了通过简单的容量承诺进一步激励“有用”数据的存储,存储矿工有额外的机会竞争经过验证的客户提供的特殊交易.此类客户在提供涉及存储有意义数据的交易意图方面获得了认证,并且存储矿工为这些交易赚取的权力将通过乘数得到增强.考虑到该乘数后,给定存储矿工拥有的总电量称为质量调整后的 电量.
- **存储市场** </br>
	客户向存储订单簿提交一个投标订单(使用PUT协议,在下一节中说明).客户必须存放订单中指定的费用并指定他们要存储的副本数量.客户可以提交多个订单,也可以在订单中指定复制因子.更高的冗余度(更高的复制因子)导致对存储故障的更高容错率(如下所述).

	==Manage.PledgeSector==
	存储矿工通过通过==Manage.PledgeSector==在区块链中通过质押交易存入抵押品来保证其对网络的存储.抵押品(Fil)在提供服务的时间内存放,如果矿工为其承诺存储的数据生成存储凭证,则将其退还.如果某些存储证明丢失,则会损失一定比例的抵押品.一旦质押交易出现在区块链中,矿工就可以在存储市场中提供其存储服务 : 他们设置价格并将要价单添加到市场的订单簿中.

	==Put.AddOrders==
	一旦质押交易出现在区块链中(在AllocTable中),矿工便可以在存储市场中提供其存储服务 : 他们设置价格并通过==Put.AddOrders==将要价订单添加到市场的订单簿中.

	==Put.MatchOrders==
	当找到匹配的要价和买价单时(通过==Put.MatchOrders==),客户将片段(数据)发送给矿工.

	==Put.ReceivePiece==
	当接收到片段,矿工运行==Put.ReceivePiece==.接收到数据后,矿工和客户都签署了交易订单并将其提交到区块链(在存储市场订单中)

	==Manage.AssignOrders==
	存储矿工的存储分为多个扇区,每个扇区包含分配给矿工的部分.网络通过分配表跟踪每个存储矿工的扇区.此时(签署交易订单时),网络会将数据分配给矿工,并在分配表中记录下来.

	==Manage.SealSector==
	当存储矿工扇区被填充时,该扇区被密封.密封是一种缓慢的顺序操作,它将扇区中的数据转换为副本,该副本是与存储矿工公钥关联的数据唯一物理副本.在复制证明期间,密封是必要的操作.

	==Manage.ProveSector==
	当为存储矿工分配数据时,他们必须反复生成复制证明以确保他们正在存储数据,证明会发布在区块链上,网络会对其进行验证.

	==Δfault==
	如果缺少任何证据或证据无效,则网络会通过存储矿工的抵押币对他们进行惩罚.
	如果大量证据缺失或无效(由系统参数Δfault定义),则网络会认为存储矿工有故障,将订单结算为失败,然后相同新订单重新引入市场.
	如果每个存储该矿工的都无法存储该片段,则该片段将丢失,并且客户将获得退款.
- **检索市场** </br>

	这是一个脱链交换,客户和检索矿工以对等方式彼此发现.一旦客户和矿工就价格达成协议,他们便开始使用小额付款逐笔交换数据和币.

	Get.AddOrders
	检索矿工通过在网络上散播他们的要价单 : 他们设置价格并将要价单添加到市场的订单簿中.

	Get.MatchOrders
	客户向投标市场订单簿提交投标订单.检索矿工检查其订单是否与客户的相应投标订单相匹配.

	Put.SendPiece
	订单匹配后,检索矿工将件发送给客户(矿工发送部分数据,客户发送小额付款).收到件后,矿工和客户都签署了交易订单并将其提交给区块链.
	
--------------------------------------------------------------------------------	

#### 什么是Filecoin

IPFS是一个去中心化存储网络，Filecoin是IPFS存储的激励层，Filecoin作为生态激励来保证 IPFS 节点的运行。

FIL 是 Filecoin 项目基于 Filecoin 公链发行的 Token，全称是：Filecoin ,符号是：FIL。

Filecoin项目主要组成部分
- 去中心化存储网络DSN
- 复制证明PoRep
- 构建两个可验证市场，即存储市场和检索市场

#### Filecoin实现方案

Filecoin测试网目前在一个Filecoin实现方案lotus（https://github.com/filecoin-project/lotus/）上运行，网络本身与具体的实施方案无关。

在接下来的几个月中，包括go-filecoin在内的几个（目前已经有四套lotus、go-filecoin、forest以及fuhon 其中Forest（由ChainSafe在Rust中实现）和fuhon（由Soramitsu在C ++中实现））实施方案，将能够在Filecoin测试网上进行互操作。而目前我们测试网都是基于lotus实现，官方为什么实现四套实施方案，主要基于安全考虑（考虑到项目的难度、进度和可控性，具有可在同一网络上互操作的多个软件实现，可以降低一个实现中的重大错误抬高头并破坏整个网络的风险。）

您可以在GitHub上的各个实现中跟踪每个实现的进度：

*   go-filecoin（用Go编写）
*   lotus（用Go语言编写）
*   fuhon（用C ++编写）
*   forest（用Rust编写）

说明：Filecoin协议尚未100%稳定和完成，因此测试网并非是稳定的网络。测试网的目的是让我们发现并且修复bug，测试网启动至今已经被多次攻击，比如内存溢出漏洞、空指针攻击等方式，官方也在根据线上的问题，快速修正问题。测试网网络已经多次被重置。

#### 核心原理（共识机制）

Filecoin – Lotus存储证明了什么？
参考URL: https://www.lianyi.com/zixun/2201284
【协议学院】Filecoin 存储封印和证明初步解析
参考URL: https://www.jianshu.com/p/5a6febf1578b

共识机制是所有区块链项目的存在的基础和灵魂。
Faincoin创新的Filecoin 区块链共识机制，目前流行的区块链共识机制有POW、POS、DPOS等，而Filecoin将创新开发采用了一种混合共识机制——复制证明（PoRep）十 时空证明（PoSt）十 预期共识(Expected Consensus，EC)。

这种混合共识机制不浪费资源和能量，又解决实际应用问题，即共享存储空间，又与实体经济结合，是我们最能预见的第一个区块链＋实体经济的项目。

Filecoin协议将使用复制证明（Proof-of-Replication）和时空证明（Proof-of-Spacetime）来证明文件已经分配在记忆存储器里的它们自己的特定位置，并随着时间变化不断被存储。

官网FAQ描述：
我们对于以Hash为基础的工作量证明（Proof of Work) 所带来的能源浪费感到失望。比起工作量证明复制（Proof of Work)，复制证明（Proof-of-Replication）不仅耗能少，而且所需工作证明了矿工正在为网络提供宝贵的资源 - 即额外的存储容量。 此外，区块奖励可以激励矿工尽可能多地贡献存储容量，从而降低Filecoin网络上的储存成本。

#### 复制证明（Proof of Replication）

深度剖析复制证明论文
参考URL: https://blog.csdn.net/ipfs_newb/article/details/81318534
科普 | 如何理解Filecoin的复制证明和时空证明？
参考URL: https://www.jinse.com/blockchain/414056.html
【Filecoin源码仓库全解析】第七章：了解PoRep与PoSt并参与复制证明游戏
参考URL: https://blog.csdn.net/weixin_33725515/article/details/91388369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-6.nonecase

复制证明（PoRep）是一种新型的存储证明方案，它能够让存储矿工说服用户和其他矿工，数据已经被复制到了它的矿机上。这种方案能有效的阻止女巫攻击、外包攻击和生成攻击的存储作弊问题，以下是复制证明的简化步骤：

在Filecoin协议中，存储供应商要让他们的客户相信，客户所付费的数据已经被他们存储，**存储供应商通过生成“复制证明”（PoRep）和“时空证明”(PoST)给区块链网络或者客户来验证存储的真实性。**而我们说的复制证明和时空证明就是来实现这一验证功能的基础算法。

复制证明（PoRep），**证明数据的一个单独的拷贝已经在一个特定的扇区内创建成功。复制证明由封印（Seal）操作完成，封印操作创建一份数据的拷贝，并产生相应的复制证明。** 这是一种新型的存储证明方案，它能够让存储矿工说服用户和其他矿工，表明数据已经被复制到了它的矿机上。

复制证明也是一种交互式协议。当**证明人P**:（a）承诺存储某数据D的n个不同的副本（独立物理副本），然后（b）通过响应协议来说服**验证者V**，表明P确实已经存储了每个副本，这是复制证明的简化步骤。

复制证明必须能够防范以下三种常见的攻击方式：女巫攻击，外源攻击和生成攻击，他们的共同特点是攻击矿工实际存储的数据大小要比声称存储的数据小，这样攻击矿工就能获得本不该他获得的报酬。

*   女巫攻击（Sybil Attack）：
    利用n个身份，承诺存储n份数据D，而实际上存储小于n份（比如1份），但是却提供了n份存储证明，攻击成功。

*   外部数据源攻击（Outsourcing Attack）:
    当攻击者矿工收到检验者要求提供数据D的证明的时候，攻击者矿工从别的矿工那里生成证明，证明自己一直存储了数据D，而实际上没有存储，攻击成功。

*   生成攻击（Generation Attack）:
    攻击者A可以使用某种方式生成数据D，当检验者验证的时候，攻击者A就可以重新生成数据D来完成存储证明，攻击成功。

**PoRep本质是一个加密时间长，解密时间短且证明与验证过程高效的算法**， 这个过程在学术圈，被称为可验证时延加密（Verifiable Time-Delay Encoding Function）。

Filecoin证明机制的角色和过程可以抽象成如下，挑战者、证明者、检验者。他们可以是矿工、用户或者任何网络内其他角色。涉及的定义包括如下：

*   挑战（challenge）：系统对矿工发起提问，可能是一个问题或者一系列问题，矿工正确的答复，则挑战成功，否则失败。
*   证明者（prover）：一般只矿工。向系统提供证明了完成系统发起的挑战。
*   检验者（verifier）：向矿工发起挑战（challenge）一方，来检测是否矿工完成了数据存储任务。
*   数据（data）：用户向矿工提交的需要存储或者矿工已经存储的数据。
*   证明（proof）：矿工完成挑战（challenge）时候的回答。

验证者会按照一定的规则向矿工提起挑战，挑战是随机生成的，矿工不能提前获知。矿工作为证明者相应向检验者提交证明，证明的生成需要原始数据与随机挑战信息。证明生成后，证明者会交给验证者，并由验证者判定该证明是否有效，如果有效，则挑战成功。

PoRep的目标是确保矿工确实在自己的存储设备上存有某个数据的备份，PoSt的目标则是让存储矿工持续证明自己在约定时间内存储了该份数据。

**“复制证明”挖矿分为Pre1、Pre2和commit 3个阶段。Pre1是对数据进行编码，Pre2是对编码后的结果计算哈希，commit则是对编码后的结果生成零知识证明，以备“时空证明”算法进行检验。**

**其中，Pre1是单线程工作，运算的时间长，Pre2是多线程，也即CPU会被用满。这些特性对CPU提出了较高的要求，需要用AMD的芯片，且要有SHA扩展、可以加速。带有SHA扩展的CPU可将Pre1的运算过程提速3-4倍。**

#### 时空证明（PoSt）

Filecoin测试网12日凌晨上线，星际大陆带你回顾什么是时空证明
参考URL: https://baijiahao.baidu.com/s?id=1652695987787883881&wfr=spider&for=pc
Filecoin挖矿：什么是时空证明？
参考URL: https://baijiahao.baidu.com/s?id=1657844007685602759&wfr=spider&for=pc

我们如何证明数据在一段时间内都一直被存储？为了解决这个问题，filecoin介绍了新的证明，时空证明（proof-of-spacetime,post），时空证明提出了证明链的数据结构，证明链由挑战（challenge）和证明（proof）链接起来形成，在证明链的基础上添加上时间段，这样就得到了一段时间内的矿工存储数据的证明，这就是时空证明（Proof of Spacetime，PoSt），

PoST即Proof of Spacetime，时空证明，这一操作是为了证明存储节点在一定时间段内存储了相应文件，而PoST证明的生成涉及较大计算量，**GPU的PoST计算速度要快于CPU，因此，引入GPU挖矿可以确保在规定时间内完成PoST证明。之所以要求矿工在一个区块周期内完成PoST计算则是为了增加攻击者的攻击成本，因为PoST的计算量较大。**

这也就是官方所说的“GPU只是对CPU的一种补充”的意思。开发团队成员Why曾解释过：“如果能找到别的方法来实现快速计算，就不需要GPU。”

**时空证明可以理解为持续的复制证明，即矿工必须不断的生成证明，并在一个提交周期内提交存储证明**，如果存储服务商没有在提交周期内连续及时提交证明，会被系统扣除部分代币。

仅当矿工在给定时期内因赢得大块奖励而赢得了选举票时，才在选举时空（“ ElectionPoSt”）中运行SNARK 。每当矿工赢得选举票时，配置就使用GPU的功能来计算PoSt SNARK的输出结果，准确计算出每个纪元周期（约20秒）内的PoSt SNARK。PoSt所需的GPU功能在很大程度上取决于矿工在任何给定时期拥有多少张获胜选举票，这与他们在网络中的存储比例有关。

官方还建议使用较低延迟的网络连接来按时提交PoSt。如果矿工多次未能按时提交PoSt，则可能导致赢得较少的区块奖励，并增加被削减的风险。

总结： 通过（时空证明（Proofs-of-Spacetime）持续证明存储。

#### 零知识证明

零知识证明 - zkSNARK入门
参考URL: https://www.jianshu.com/p/828fef53cf13
Filecoin – Lotus存储证明了什么？
参考URL: https://www.lianyi.com/zixun/2201284

零知识证明，zkSNARK，zero-knowledge Succint Non-interactive ARguments of Knowledge的简称

零知识证明（Zero-Knowledge Proof）或零知识协议是一种基于概率的验证方法，包括两部分：宣称某一命题为真的证明者（prover）和确认该命题确实为真的验证者（verifier）。

零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的，在密码学中非常有用。

顾名思义，零知识证明就是既能充分证明自己是某种权益的合法拥有者，又不把有关的信息泄漏出去，即给外界的 “知识” 为“零”。

“能够在不知道用户是谁，或者他们有多少钱的情况下判断‘一个用户是否有足够的钱发送给另一个用户’的问题，是零知识证明在区块链中的主要应用之一。”——Demiro Massessi

例如，当前网站将用户密码的哈希值存储在其 web 服务器中。为了验证客户端是否真的知道密码，大多数网站目前使用的方法是对客户端输入的密码进行哈希值计算，并将其与存储的结果进行比较。

零知识证明可以保护用户的帐号信息不被泄露。如果零知识证明可以实现，那么在客户的密码是未知的情况下，仍然可以在客户端登录进行身份验证。当服务器受到攻击时，用户的帐户仍然是安全的，因为客户的密码没有存储在 web 服务器中。

零知识证明在区块链中的应用
比特币和以太坊网络都使用公共地址来代替验证者和证明者的真实身份，使得交易部分匿名; 只有发送和接收地址，以及交易数量是公众知道的。但是，通过区块链上提供的各种信息，如交互记录等，可以发现地址的真实身份，存在隐私暴露的隐患。

用了零知识证明之后，发送方、接收方和第三方的细节信息可以保持匿名，同时保证交易有效。

最早使用零知识证明技巧的区块链叫做 Zcash，实际的作法叫做 **Zk-Snarks**，这是许多零知识证明的做法之一，也是最有名的一个。

Zk-Snarks 是 “零知识简洁无交互知识认证” 的简称，是一种在无需泄露数据本身情况下证明某些数据运算的一种零知识证明。

Zk-Snarks 技术缩减了证明所需的时间和验证它们所需的计算量。它能够证明有效交易的条件已经满足，而不需要透露交易所涉及的地址或交易量的任何关键信息。

**Zcash 可以将交易纪录上的汇款者、收款者和金额都经过加密隐藏起来，因此矿工无从得知这些交易上的细节，但仍然可以验证交易。不过，目前多数使用者在 Zcash 上的交易，还是选择未经加密的作法，因为花费的成本比较高。**

根据 Zk-Snarks 白皮书，Zk-Snarks 是第一个不依赖任何信任设置实现区块链验证的系统，而随着计算数据数量的增加，计算速度呈指数增长。它不依赖于公钥加密系统，而且更简单的假设使它在理论上更安全，因为它唯一的加密假设是哈希函数 (如 SHA2) 是不可预测的。零知识证明和 Zk-S(T|N)ARK 等技术的测试和采用需要时间。

#### 相关实现

Lotus/Filecoin项目由三部分组成：
1/ Lotus Blockchain部分 – 实现区块链相关逻辑（共识算法，P2P，区块管理，虚拟机等等）。注意的是，Lotus的区块链相关的数据存储在IPFS之上。go语言实现。
2/ RUST-FIL-PROOF部分 – 实现Sector的存储以及证明电路。也就是FPS（Filecoin Proving Subsystem）。**Rust语言实现。**
3/ Bellman部分 – 零知识证明(zk-SNARK)的证明系统，主要是基于BLS12_381椭圆曲线上，实现了Groth16的零知识证明系统。Lotus官方推荐采用Nvidia的2080ti显卡，也主要做这部分的性能加速。**Rust语言实现。**

Filecoin的存储封印（Sealing）和证明（PoRep & PoSt）是用rust语言编写，而且是单独成篇的，也就是说可以单独拿出来玩。

ilecoin复制游戏程序的源码可以到以下地址下载：
https://github.com/filecoin-project/replication-game

如果你不想下载源码，直接下载可执行代码的话，直接到这里：
https://github.com/filecoin-project/rust-fil-proofs/releases

#### 官方FAQ

参考URL: https://filecoin.io/zh-cn/faqs/

##### IPFS和Filecoin之间有什么联系?

Filecoin和IPFS是互补协议，两者均由Protocol Labs创建。IPFS 允许网络中的参与者互相存储，索取和传输可验证的数据。 IPFS是开源的，可以被免费下载和使用，并且已经被大量的团队使用。运用IPFS，各个节点可存储它们认为重要的数据；没有简单的方法可以激励他人加入网络或存储特定数据。 为了解决这一关键问题，Filecoin的设计旨在提供一个持久的数据存储系统。在Filecoin的激励结构下，客户付费以在特定的冗余和可用性水平上存储数据，矿工通过不断地存储数据并以加密方式证明数据存储来获得付款和奖励。 简而言之：IPFS按内容寻址并使其移动； Filecoin就是缺失的激励机制。

Filecoin还使用了IPFS的许多性能。例如：

Filecoin将IPLD用于区块链数据结构
Filecoin节点使用libp2p保证安全连接
节点之间的消息传递和Filecoin块传播使用libp2p发布订阅

此外，Filecoin核心团队包括IPFS核心团队的成员。 IPFS和Filecoin之间的兼容将尽可能无缝对接。即使在Filecoin发布之后，我们仍然期望IPFS和Filecoin的开源社区们继续协作和提升两个项目的兼容性。

##### 我什么时候应该选择使用Filecoin？何时应该选择IPFS?

首先，值得重复的是，Filecoin和IPFS相互补充，并且具有显着的交叉兼容性。 我们正努力地使自发的IPFS存储和付费Filecoin存储之间的转换更加简单。

使用IPFS，您可以通过直接提供硬件或从第三方购买存储来负责您自己的存储节点。 在IPFS上，单独的节点可以存储他们认为重要的内容； 没有任何简单的方法来激励他人来保证储存你的数据在他们的系统里。Filecoin提供了缺少的激励机制。

如果您希望维护自己的存储节点，或者和外部协作来合作存储数据，IPFS将可能会是您的首选方案。如果您希望支付具有竞争力的价格并在特定的冗余和可用性下为您管理信息存储，Filecoin可能是您的首选方案。












	
	
	
	
	
	
	
	
	
	
	
	
	
