---
title: Ethereum2的阶段0探索
tags: 小书匠语法,技术
renderNumberedHeading: true
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---

[toc]

#### eth2参与者的组织

- 验证者 staking validator 
需要质押32ETH 最低16ETH会被退出
区块的提议者 block proposer
见证者 attesters 
成为验证者需要在eth1网络进行抵押,使用deposit文件来创建对应关系,deposit文件是由本地通过一组命令创建的能建立关联并生成eth2私钥文件的程序来创建的.

- 委员会 committee
最少会有128个 staking validator组成,其中一个是 block proposer,其他的是attesters,最多可以有2048个staking validtor
当每个epoch开始前,所有验证者都已经均匀的分配到每个slot中,并先以最少每128位组成委员会,最对组成64个委员会后才开始平均的扩大每个委员会的人数规模.

- 时隙和时段 slot and epoch
一个epoch有32个slot,所以有384秒==6.4分钟
一个slot是12秒

#### 投票==发出见证消息

- 区块投票 LMD GHOST 
选出信标链的slot区块,只有分配到这个slot的委员会成员需要投票

- 检查点投票 Casper FFG 投票
选出上一个检查点,每个时段都需要所有人发起投票

- 见证消息 attestations
是一个validator在每个时段内发出的一个包含了一条 LMD GHOST投票和一条 Casper FFG投票的信息.

- 合理化 justified
一个时段结束的时候，如果其检查点得到了 2/3 的总余额支持（形成了多数票），那么该检查点就被合理化（justified）了。

- 最终化 finalized
如果一个检查点 B 已经得到合理化，其下一个时段的检查点也被合理化了，那么 B 就被敲定（finalized）了

- 签名聚合
委员会机制使得汇总所有的见证人签名、变成单个聚合签名在技术上的优化成为可能。如果同一委员会中的所有验证者都作了同样的 LMD GHOST 和 FFG 投票，则他们的签名可以聚合起来（成为单个签名）。

- 信标链验证者奖惩措施
	1.  见证人奖励
	2.  见证人惩罚
	3.  对质押者来说典型的贬值风险
	4.  罚没（slashing）及举报人奖励
	5.  区块提议者奖励
	6.  怠惰惩罚（inactivity penalty）
	7.  根据介绍文章介绍的,好的验证者赚到的和坏的验证者失去的是相等的

#### 验证者的职责

>关于验证者的职责这里直接转载 [ethfans上关于验证者职责的FAQ科普](https://ethfans.org/posts/eth-2-validator-faq-from-launchpad)

1. 经济激励机制是如何帮助用户保持活跃和诚实的？

除了会因为离线而遭受惩罚之外，验证者还会因为作恶而遭受惩罚 —— 例如，投票给无效或有冲突的区块。

另一方面，如果验证者 所提议/所见证 的区块被添加到了区块链上，验证者就会获得奖励。

基本概念是：

*   帮助网络达成共识的行为会获得奖励
*   妨碍共识的无意行为（或不作为）会招致轻微惩罚
*   恶意行为会招致严重惩罚（或称**罚没**）

换言之，验证者在努力获得奖励的同时也在为整个网络做贡献。

2. 奖励/惩罚 是如何发放的？

请记住，每个验证者都有自己的余额 —— 初始余额则可在保证金合约中看到。

以太坊网络规则会基于验证者的履职情况定期更新其余额。

换言之，验证者所获得的奖惩都会在余额中反映出来。

3. 奖励/惩罚 多久发放？

大约每 6.5 分钟（即，一个 epoch ）发放一次。每个 epoch 期间，网络都会评估每个验证者的表现，并相应给予奖励或惩罚。

4. 奖励/惩罚 金额有多大？

这个问题很难回答，因为在计算时需要考虑很多因素。

验证交易所获得的奖励主要受网络总权益量（即，验证者总数）的影响。根据总权益量，验证者的最高年化收益率可能在 2% 至 20% 之间。

在验证者总数固定的情况下，奖励/惩罚主要取决于验证者的余额规模 —— 如果提供证明的验证者的余额越高，ta 所受到的奖励/惩罚就越高；余额越低，奖励/惩罚就越低。

请注意，这种动态机制是以不那么明显的方式运作的。要想了解其具体原理，你先要理解**有效余额（effective balance）**这个概念。如果你对这个概念还不熟悉，我们建议你阅读[这篇文章](https://www.attestant.io/posts/understanding-validator-effective-balance/)。

5. 为什么奖励取决于网络中的验证者总数？

区块奖励是根据网络中的 ETH 总权益量按比例计算的。

简单来说，如果 ETH 总权益量很少，奖励（利率）就很高，但是随着权益量增加，每个验证者所获得的奖励（利率）就会降低。

为什么会有这种动态调整？虽然本文不会揭开其中的真相，但是直觉告诉我们，为了确保网络良好运转，验证者总数不能低于某个下限（ETH 总质押量也是）。因此，为了激励更多验证者参与进来，利率需要维持在较高水平，直到验证者总数达到下限为止。

6. 如果离线，验证者会遭到什么惩罚？

视情况而定。除了[实际余额的影响](https://www.attestant.io/posts/understanding-validator-effective-balance/#the-impact-of-effective-balance-on-validating)之外，还需要注意两个重要情况：

	1. 如果绝大多数（2/3）验证者都在线，那么离线所造成的惩罚较低，因为有足够多的验证者在线，可以实现区块的终局性。**这是预料之中的情况。**
	2. 如果有超过 1/3 的验证者同时离线，离线惩罚就会较高，因为网络无法继续实现区块的确定性。**这种属于不太可能发生的极端情况。**

请注意，如果是第二种情况，离线验证者会在 21 天内逐渐损失高达 50%（16 ETH）的权益量。21 天之后，这批验证者就会被逐出验证者池。这样一来，网络就可以恢复正常，开始达成区块的终局性。

7. 正常运行时间占到多大比例，诚实的验证者才能实现盈利？

总的来说，只要验证者的正常运行时间超过 50% ，就能实现盈利。

这就意味着，验证者不需要备份客户端或冗余的网络连接，因为离线的后果并没有那么严重。

8. 作恶的验证者会遭受什么惩罚？

同样视情况而定。恶意行为（例如，投票给无效或有冲突的区块）会让验证者遭到罚没。

最低罚没金额是 1 ETH ，但是**如果其他验证者在同一时间遭到罚没，这一金额还会增加。**

其目的是尽可能减少验证者因无心之失而蒙受的损失，同时抑制协同攻击。

9. 罚没是什么？

罚没有两个目的：（1）大幅提高攻击 ETH 2.0 的成本，使攻击无利可图；（2）通过检查验证者是否履行其职责来防止他们偷懒。所谓的罚没，指的就是如果有验证者被证明作恶，ta 的权益（中的一部分）就会被销毁。

遭到罚没的验证者无法继续参与网络的共识机制，会被强制退出。

（译者注：在这几个问题的答案中没有显明的信息是：对一名验证者来说，每一个 epoch （6.4 分钟）就要发出一条见证消息（attestation，包含投票内容），而且需要发出消息的时间在一个 epoch 中的位置不是固定的。显然，上述验证者职责的履行不可能由人手动操作程序来执行，必定是自动化的。因此，验证者会不会被罚没，高度依赖于所用的客户端软件。因此，有意自己运行验证者的用户，首先要关心自己所用的客户端性能好不好，保护措施到不到位。）

#### 见证消息的聚合

> 见证消息的聚合 和 见证消息打包 这两部分的内容转载自 [ethfans上定义eth2.0验证者的质量一文](https://ethfans.org/posts/defining-attestation-effectiveness#render)

虽然一条见证消息的数据量比较小，但是验证者有数万名 ， 数据量很快就会积少成多。由于这些数据将永远存储在区块链上，减少数据量非常重要。这是通过一个被称为 “聚合（aggregation）” 的过程实现的。

聚合就是将多条 committee（委员会）、chain head vote（链首投票）、finality vote（终局性投票）都相同的见证消息（译者注：即同一委员会中作了相同的链首投票和终局性投票的见证消息） 合并成一个 _聚合见证消息_ （ _aggregate attestation_ ）：

![](https://raw.githubusercontent.com/OliverRen/olili_blog_img/master/Ethereum2的阶段0探索/2020814/1597393960519.png)

聚合见证消息与单个见证消息存在两点差异。首先，前者有多个验证者。其次，聚合签名是由单个见证消息的签名合并生成的。聚合见证消息的存储效率很高，但是会增加通信和计算方面的负担（详见下文）。

如果我们强制要求每个验证者将所有见证消息聚合起来，那么将每个见证消息传给每个验证者所需的通信量很快就会导致网络过载。同样地，如果聚合只是可选项，那么验证者就不会浪费自己的资源这么做。因此，网络会选择一组验证者来负责进行聚合 1 。出于利益考虑，验证者会认真履行职责，因为包含较多验证者的聚合见证消息更有可能被添加到区块链上，验证者就更有可能获得奖励。

执行这一聚合过程的验证者就是 聚合者（aggregator） 。

#### 见证消息的打包过程

见证消息是如何打包到 ETH 2.0 区块链上的？其过程如下 :
1.  每个参与见证的验证者都会使用其所拥有的链状态的相关数据生成见证消息；
2.  见证消息会通过 ETH 2.0 网络广播给相关聚合者；
3.  每个聚合者在收到见证消息后都会将它与其它具有相同声明的见证消息聚合起来；
4.  聚合见证消息会通过 ETH 2.0 网络广播至所有节点；
5.  只要是没有在链上看见该聚合见证消息的区块提议者都可以将其打包到区块中。

一旦你发现打包距离大于 1 ，就要了解其背后原因。可能有以下几个原因：

1. 见证消息生成延迟
验证者可能会遇到一些问题，从而导致见证消息生成延迟。例如，验证者所拥有的链状态相关数据过时，或者验证者在生成和签署见证消息上花费时间过久。无论出于哪种原因，见证消息生成步骤的迟滞都会对整个流程的剩余步骤产生连锁反应。

2. 见证消息广播延迟
验证者生成见证消息后需要通过网络将见证消息广播至聚合者处。这一流程的本质意味着，广播宜早不宜迟，因为这样可以确保验证者及时收到该见证消息，并将其合并到聚合见证消息中。验证者应该连接到足够多的对等节点，从而确保自己能尽快将见证消息广播给聚合者。

3. 聚合见证消息生成延迟
聚合者可能会推迟见证消息的聚合流程。最常见的原因是，聚合者节点已经因为生成见证消息而过载，但是如果需要聚合大量验证者，聚合算法的速度也会造成巨大延迟。

4. 聚合见证消息广播延迟
与见证消息广播延迟类似，聚合见证消息也需要在网络中广播，因此存在相同的延迟风险。

5. 区块生成失败
要想让见证消息上链，首先要将它打包到区块中。但是，区块生成并不一定总能成功。 有两种情况会导致区块生成失败：1\. 验证者离线；2\. 验证者与网络中的其他验证者失去同步，导致其生成的区块因包含无效数据而被拒绝。如果区块生成失败，就无法确保见证消息在同一个 slot 内上链，导致打包距离大于最佳距离。

区块生成失败还会产生其它影响，即，增加了可打包进下一个区块的见证消息总量。如果可打包的见证消息总量超过了区块容量，区块生产者很可能优先打包那些可以带来较高收益的见证消息，也就是那些打包距离最小的见证消息。这就有可能导致那些错过最佳打包距离的见证消息一再被推后，因为它们能带来的收益越来越低。

由于验证者无法控制区块生成 ，我们定义了 “最早打包 slot（earliest inclusion slot）” 这一术语。最早打包 slot 指的是见证消息生成后的第一个生成有效区块的 slot 。 见证消息无法打包到一个不存在的区块中，因此，以见证消息生成后的第一个 slot 为标准也衡量不出见证者的效率。这个标准就体现了这些考量，将 “最早打包 slot” 定义为见证消息生成后的第 1 个产生有效区块的 slot（译者注：即过滤掉区块生产者的失误对衡量验证者效率造成的影响）。

6. 恶意行为
尽管如此，恶意参与者依然有可能拒绝将见证消息聚合，或者拒绝将见证消息打包到区块中。前者的风险可以用让每个验证者团体都有多个聚合者来缓解 。为降低后者的风险，不打包见证消息需要承担一定的成本。但是，参与见证的验证者无法迫使区块生成者打包见证消息，因此如果不打包见证消息所产生的收益高于其成本，参与见证的验证者就束手无策了。

#### 计算见证消息的有效性

考虑到区块生成和打包距离，见证消息有效性可以理解为见证消息对网络的用处有多大。区块有效性的正式定义是：

![](https://raw.githubusercontent.com/OliverRen/olili_blog_img/master/Ethereum2的阶段0探索/2020814/1597394459986.png)

区块有效性是以百分比呈现的。下表列出了一些示例：

![5](https://raw.githubusercontent.com/OliverRen/olili_blog_img/master/Ethereum2的阶段0探索/2020814/1597394459987.png)

区块距离的上限是 32 。如果未能在区块距离达到上限之前将见证消息打包进区块，则该见证消息的有效性为 0。

#### 总结

- 验证者干什么
1. 在每一个时段，验证者都被均匀分配到不同时隙中，并进一步划分成相同规模的委员会。验证者只有 1 个应召的时隙，也只会存在于 1 个委员会中。
2. 由阐述1可得,一个时段中的所有验证者，通过集体决策尝试敲定某个检查点；方法是 FFG 投票；
3. 各时隙中的所有验证者，通过集体决策尝试选出信标链的顶端区块：方法是 LMD GHOST 投票；
4 .一个委员会中的所有验证者，通过集体投票尝试将某个分片交联到信标链上。
委员会分为信标链委员会和分片链委员会,我们现在看的都是信标链委员会.
分片委员会即每个slot中每个委员会会尝试交联到一个shard分片上即成为了这个分片这个slot中的分片委员会.

- 验证者怎么分
随着staking validator的增多,启动信标链开始
1. 1->128组成一个最小的委员会
2. 然后委员会数量增多从 1->64 这对应着映射到的shard切片数目是64个,如果验证者数量不足,是会减少委员会的数量的
3. 随着staking validator继续增多,会扩大委员会内成员的规模 128->2048
4. 委员会的规模都是一样大的,所以每次增减都是64的倍数

- 每个epoch可以容纳的验证者数量
在一个时隙 slot =12秒内 会有64个委员会的需要,即信标链和每一个分片链上都需要一个委员会
在一个时段 epoch=32个slot
故一个epoch可以容纳的validator
`2048 staking validator * 64 committee * 32 slot`
相应的需要质押的eth有一亿多,已经超过了目前eth1上的发行总量

- 信标链启动门槛
128 * 2 * 64 需要 16384个staking validator,即128个验证者组成一个委员会,每个slot都需要最少64\*2个委员会
在达到这一初始门槛之前，信标链将不会发放质押奖励。之后每一个epoch结束后都能得到eth奖励.

- 信标链上的验证者们怎么干=>发出见证消息=>即怎么投票
1. 每个epoch开始前一小段时间,就已经把所有验证者们被均匀地分配到32个时隙中，然后进一步分配到同等规模的各委员会中。.这叫做schedual block,那么可以理解最多是有32个schedual block的
2. 所有验证者都要在自己所在的时隙出发出见证消息，指出信标链的顶端。每个委员会都要在自己所在的时隙尝试交联(映射)到特定的某个分片。混洗算法会增减委员会的数量，以保证每个委员会都至少有 128 名验证者。
3. 每个验证者在自己的时隙中可以对自己的顶端块和检查点进行见证,并发出见证消息投票
理想情况下,每个epoch下所有的验证者正好都会分配到了32个slot中,并且正好都在slot中分配到了委员会中,并且都在自己的slot时隙中收到了当前bp的所提议的块(收集了之前slot中委员会,验证者们所发出的见证消息提案),这样该slot中的所有委员会中的所有验证者就会发出相同的见证消息,见证消息被聚合,作为该委员会中的所有提案等待后面的slot中的bp进行收集和打包.
现实情况是,验证者被分配到了slot中组成委员会,有可能有的验证者并没有被加入到委员会中,或者说bp压根就没有在线提议了该块,slot中的验证者也不可能都提议相同的提案,更加不可能都会后续相同的slot尽心打包.所以就会在整个打包过程中出现了一个错综复杂的情况.

> 把validator都划分好之后,不是说他们一定在属于自己时隙的时间内把见证消息被打包,在包含属于自己的时隙和之后一共32个时隙内这个见证消息都有机会被打包,当然被就是后面的slot的bp进行打包了

> 所以虽然每个时段一个validator只有一次投票的权力,但是由于见证消息打包的时机不同,所以有可能一个validator在一个时段内是会有一个前面时段遗留下来的见证消息和本时段内投的见证消息,共2条见证消息被打包的.

> 由此衍生,如果网络很差,见证消息不能被及时的打包,比如选的bp好巧不巧都skip了.或者参与投票的人突然大面积的失联,参与度降低的化,就会导致在一个时段的边界时隙对本时段检查点不能justified合理化,于是前一个时段的检查点也不能被最终化 finalized.直到后面slot继续生成,才会合理化了一个时段,这就有可能会最终化两个时段之前的区块,而不是前一个.必须要求Casper FFG的投票超过2/3

