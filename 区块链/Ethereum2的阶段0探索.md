---
title: Ethereum2的阶段0探索
tags: 小书匠语法,技术
renderNumberedHeading: true
grammar_abbr: true
grammar_table: true
grammar_defList: true
grammar_emoji: true
grammar_footnote: true
grammar_ins: true
grammar_mark: true
grammar_sub: true
grammar_sup: true
grammar_checkbox: true
grammar_mathjax: true
grammar_flow: true
grammar_sequence: true
grammar_plot: true
grammar_code: true
grammar_highlight: true
grammar_html: true
grammar_linkify: true
grammar_typographer: true
grammar_video: true
grammar_audio: true
grammar_attachment: true
grammar_mermaid: true
grammar_classy: true
grammar_cjkEmphasis: true
grammar_cjkRuby: true
grammar_center: true
grammar_align: true
grammar_tableExtra: true
---

[toc]

#### eth2参与者的组织

- 验证者 staking validator 
需要质押32ETH 最低16ETH会被退出
区块的提议者 block proposer
见证者 attesters 
成为验证者需要在eth1网络进行抵押,使用deposit文件来创建对应关系,deposit文件是由本地通过一组命令创建的能建立关联并生成eth2私钥文件的程序来创建的.

- 委员会 committee
最少会有128个 staking validator组成,其中一个是 block proposer,其他的是attesters,最多可以有2048个staking validtor
当每个epoch开始前,所有验证者都已经均匀的分配到每个slot中,并先以最少每128位组成委员会,最对组成64个委员会后才开始平均的扩大每个委员会的人数规模.

- 时隙和时段 slot and epoch
一个epoch有32个slot,所以有384秒==6.4分钟
一个slot是12秒

#### 投票==发出见证消息

- 区块投票 LMD GHOST 
选出信标链的slot区块,只有分配到这个slot的委员会成员需要投票

- 检查点投票 Casper FFG 投票
选出上一个检查点,每个时段都需要所有人发起投票

- 见证消息 attestations
是一个validator在每个时段内发出的一个包含了一条 LMD GHOST投票和一条 Casper FFG投票的信息.

- 合理化 justified
一个时段结束的时候，如果其检查点得到了 2/3 的总余额支持（形成了多数票），那么该检查点就被合理化（justified）了。

- 最终化 finalized
如果一个检查点 B 已经得到合理化，其下一个时段的检查点也被合理化了，那么 B 就被敲定（finalized）了

- 签名聚合
委员会机制使得汇总所有的见证人签名、变成单个聚合签名在技术上的优化成为可能。如果同一委员会中的所有验证者都作了同样的 LMD GHOST 和 FFG 投票，则他们的签名可以聚合起来（成为单个签名）。

- 信标链验证者奖惩措施
1.  见证人奖励
2.  见证人惩罚
3.  对质押者来说典型的贬值风险
4.  罚没（slashing）及举报人奖励
5.  区块提议者奖励
6.  怠惰惩罚（inactivity penalty）
根据介绍文章介绍的,好的验证者赚到的和坏的验证者失去的是相等的

关于验证者的职责这里直接转载 [ethfans上关于验证者职责的FAQ科普](https://ethfans.org/posts/eth-2-validator-faq-from-launchpad)

#### 验证者的职责

1. 经济激励机制是如何帮助用户保持活跃和诚实的？

除了会因为离线而遭受惩罚之外，验证者还会因为作恶而遭受惩罚 —— 例如，投票给无效或有冲突的区块。

另一方面，如果验证者 所提议/所见证 的区块被添加到了区块链上，验证者就会获得奖励。

基本概念是：

*   帮助网络达成共识的行为会获得奖励
*   妨碍共识的无意行为（或不作为）会招致轻微惩罚
*   恶意行为会招致严重惩罚（或称**罚没**）

换言之，验证者在努力获得奖励的同时也在为整个网络做贡献。

2. 奖励/惩罚 是如何发放的？

请记住，每个验证者都有自己的余额 —— 初始余额则可在保证金合约中看到。

以太坊网络规则会基于验证者的履职情况定期更新其余额。

换言之，验证者所获得的奖惩都会在余额中反映出来。

3. 奖励/惩罚 多久发放？

大约每 6.5 分钟（即，一个 epoch ）发放一次。每个 epoch 期间，网络都会评估每个验证者的表现，并相应给予奖励或惩罚。

4. 奖励/惩罚 金额有多大？

这个问题很难回答，因为在计算时需要考虑很多因素。

验证交易所获得的奖励主要受网络总权益量（即，验证者总数）的影响。根据总权益量，验证者的最高年化收益率可能在 2% 至 20% 之间。

在验证者总数固定的情况下，奖励/惩罚主要取决于验证者的余额规模 —— 如果提供证明的验证者的余额越高，ta 所受到的奖励/惩罚就越高；余额越低，奖励/惩罚就越低。

请注意，这种动态机制是以不那么明显的方式运作的。要想了解其具体原理，你先要理解**有效余额（effective balance）**这个概念。如果你对这个概念还不熟悉，我们建议你阅读[这篇文章](https://www.attestant.io/posts/understanding-validator-effective-balance/)。

5. 为什么奖励取决于网络中的验证者总数？

区块奖励是根据网络中的 ETH 总权益量按比例计算的。

简单来说，如果 ETH 总权益量很少，奖励（利率）就很高，但是随着权益量增加，每个验证者所获得的奖励（利率）就会降低。

为什么会有这种动态调整？虽然本文不会揭开其中的真相，但是直觉告诉我们，为了确保网络良好运转，验证者总数不能低于某个下限（ETH 总质押量也是）。因此，为了激励更多验证者参与进来，利率需要维持在较高水平，直到验证者总数达到下限为止。

6. 如果离线，验证者会遭到什么惩罚？

视情况而定。除了[实际余额的影响](https://www.attestant.io/posts/understanding-validator-effective-balance/#the-impact-of-effective-balance-on-validating)之外，还需要注意两个重要情况：

	1. 如果绝大多数（2/3）验证者都在线，那么离线所造成的惩罚较低，因为有足够多的验证者在线，可以实现区块的终局性。**这是预料之中的情况。**
	2. 如果有超过 1/3 的验证者同时离线，离线惩罚就会较高，因为网络无法继续实现区块的确定性。**这种属于不太可能发生的极端情况。**

请注意，如果是第二种情况，离线验证者会在 21 天内逐渐损失高达 50%（16 ETH）的权益量。21 天之后，这批验证者就会被逐出验证者池。这样一来，网络就可以恢复正常，开始达成区块的终局性。

7. 正常运行时间占到多大比例，诚实的验证者才能实现盈利？

总的来说，只要验证者的正常运行时间超过 50% ，就能实现盈利。

这就意味着，验证者不需要备份客户端或冗余的网络连接，因为离线的后果并没有那么严重。

8. 作恶的验证者会遭受什么惩罚？

同样视情况而定。恶意行为（例如，投票给无效或有冲突的区块）会让验证者遭到罚没。

最低罚没金额是 1 ETH ，但是**如果其他验证者在同一时间遭到罚没，这一金额还会增加。**

其目的是尽可能减少验证者因无心之失而蒙受的损失，同时抑制协同攻击。

9. 罚没是什么？

罚没有两个目的：（1）大幅提高攻击 ETH 2.0 的成本，使攻击无利可图；（2）通过检查验证者是否履行其职责来防止他们偷懒。所谓的罚没，指的就是如果有验证者被证明作恶，ta 的权益（中的一部分）就会被销毁。

遭到罚没的验证者无法继续参与网络的共识机制，会被强制退出。

（译者注：在这几个问题的答案中没有显明的信息是：对一名验证者来说，每一个 epoch （6.4 分钟）就要发出一条见证消息（attestation，包含投票内容），而且需要发出消息的时间在一个 epoch 中的位置不是固定的。显然，上述验证者职责的履行不可能由人手动操作程序来执行，必定是自动化的。因此，验证者会不会被罚没，高度依赖于所用的客户端软件。因此，有意自己运行验证者的用户，首先要关心自己所用的客户端性能好不好，保护措施到不到位。）

#### 总结

- 验证者干什么
1. 在每一个时段，验证者都被均匀分配到不同时隙中，并进一步划分成相同规模的委员会。验证者只有 1 个应召的时隙，也只会存在于 1 个委员会中。
2. 由阐述1可得,一个时段中的所有验证者，通过集体决策尝试敲定某个检查点；方法是 FFG 投票；
3. 各时隙中的所有验证者，通过集体决策尝试选出信标链的顶端区块：方法是 LMD GHOST 投票；
4 .一个委员会中的所有验证者，通过集体投票尝试将某个分片交联到信标链上。
委员会分为信标链委员会和分片链委员会,我们现在看的都是信标链委员会.
分片委员会即每个slot中每个委员会会尝试交联到一个shard分片上即成为了这个分片这个slot中的分片委员会.

- 验证者怎么分
随着staking validator的增多,启动信标链开始
1. 1->128组成一个最小的委员会
2. 然后委员会数量增多从 1->64 这对应着映射到的shard切片数目是64个,如果验证者数量不足,是会减少委员会的数量的
3. 随着staking validator继续增多,会扩大委员会内成员的规模 128->2048
4. 委员会的规模都是一样大的,所以每次增减都是64的倍数

- 每个epoch可以容纳的验证者数量
在一个时隙 slot =12秒内 会有64个委员会的需要,即信标链和每一个分片链上都需要一个委员会
在一个时段 epoch=32个slot
故一个epoch可以容纳的validator
`2048 staking validator * 64 committee * 32 slot`
相应的需要质押的eth有一亿多,已经超过了目前eth1上的发行总量

- 信标链启动门槛
128 * 2 * 64 需要 16384个staking validator,即128个验证者组成一个委员会,每个slot都需要最少64\*2个委员会
在达到这一初始门槛之前，信标链将不会发放质押奖励。之后每一个epoch结束后都能得到eth奖励.

- 信标链上的验证者们怎么干=>发出见证消息=>即怎么投票
1. 每个epoch开始前一小段时间,就已经把所有验证者们被均匀地分配到32个时隙中，然后进一步分配到同等规模的各委员会中。.这叫做schedual block,那么可以理解最多是有32个schedual block的
2. 所有验证者都要在自己所在的时隙出发出见证消息，指出信标链的顶端。每个委员会都要在自己所在的时隙尝试交联(映射)到特定的某个分片。混洗算法会增减委员会的数量，以保证每个委员会都至少有 128 名验证者。
3. 每个验证者在自己的时隙中可以对自己的顶端块和检查点进行见证,并发出见证消息投票
理想情况下,每个epoch下所有的验证者正好都会分配到了32个slot中,并且正好都在slot中分配到了委员会中,并且都在自己的slot时隙中收到了当前bp的所提议的块(收集了之前slot中委员会,验证者们所发出的见证消息提案),这样该slot中的所有委员会中的所有验证者就会发出相同的见证消息,见证消息被聚合,作为该委员会中的所有提案等待后面的slot中的bp进行收集和打包.
现实情况是,验证者被分配到了slot中组成委员会,有可能有的验证者并没有被加入到委员会中,或者说bp压根就没有在线提议了该块,slot中的验证者也不可能都提议相同的提案,更加不可能都会后续相同的slot尽心打包.所以就会在整个打包过程中出现了一个错综复杂的情况.

> 把validator都划分好之后,不是说他们一定在属于自己时隙的时间内把见证消息被打包,在包含属于自己的时隙和之后一共32个时隙内这个见证消息都有机会被打包,当然被就是后面的slot的bp进行打包了

> 所以虽然每个时段一个validator只有一次投票的权力,但是由于见证消息打包的时机不同,所以有可能一个validator在一个时段内是会有一个前面时段遗留下来的见证消息和本时段内投的见证消息,共2条见证消息被打包的.

> 由此衍生,如果网络很差,见证消息不能被及时的打包,比如选的bp好巧不巧都skip了.或者参与投票的人突然大面积的失联,参与度降低的化,就会导致在一个时段的边界时隙对本时段检查点不能justified合理化,于是前一个时段的检查点也不能被最终化 finalized.直到后面slot继续生成,才会合理化了一个时段,这就有可能会最终化两个时段之前的区块,而不是前一个.必须要求Casper FFG的投票超过2/3

