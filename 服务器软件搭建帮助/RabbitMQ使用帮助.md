---
title: RabbitMQ使用帮助
---

[toc]

### RabbitMQ是什么

rabbitMQ说明文档rabbitMQ是什么RabbitMQ 是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP)的开源实现，由以高性能、健壮以及可伸缩性出名的 Erlang 写成（因此也是继承了这些优点）。

**首先介绍 AMQP 和一些基本概念:**

当前各种应用大量使用异步消息模型，并随之产生众多消息中间件产品及协议，标准的不一致使应用与中间件之间的耦合限制产品的选择，并增加维护成本。 AMQP 是一个提供统一消息服务的应用层标准协议，基于此协议的客户端与消息中间件可传递消息，并不受客户端 / 中间件不同产品，不同开发语言等条件的限制。 当然这种降低耦合的机制是基于与上层产品，语言无关的协议。 AMQP 协议是一种二进制协议，提供客户端应用与消息中间件之间异步、安全、高效地交互。

从整体来看， AMQP 协议可划分为三层。这种分层架构类似于 OSI 网络协议，可替换各层实现而不影响与其它层的交互。AMQP 定义了合适的服务器端域模型，用于规范服务器的行为 (AMQP 服务器端可称为 broker) 。
- ==Model== 层决定这些基本域模型所产生的行为，这种行为在 AMQP 中用 ”command”表示，在后文中会着重来分析这些域模型。
- ==Session== 层定义客户端与 broker 之间的通信 ( 通信双方都是一个 peer ，可互称做partner) ，为 command 的可靠传输提供保障。
- ==Transport== 层专注于数据传送，并与 Session 保持交互，接受上层的数据，组装成二进制流，传送到 receiver 后再解析数据，交付给 Session 层。 

Session 层需要Transport 层完成网络异常情况的汇报，顺序传送 command 等工作。

**AMQP 当中有四个概念非常重要：**
虚拟主机（ virtual host ），交换机（ exchange），队列（ queue ）和绑定（ binding ）。

- ==虚拟主机==（ virtual host ）：一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？ RabbitMQ 当中，用户只能在虚拟主机的粒度进行权限控制。因此，如果需要禁止 A 组访问 B 组的交换机 / 队列 / 绑定，必须为 A 和 B 分别创建一个虚拟主机。每一个 RabbitMQ 服务器都有一个默认的虚拟主机 “/” 。

- ==队列==（ Queue ）：由消费者建立的，是 messages 的终点，可以理解成装消息的容器。消息一直存在队列里，直到有客户端或者称为 Consumer 消费者连接到这个队列并将 message 取走为止。队列可以有多个。

- ==交换机==（ Exchange ）：可以理解成具有路由表的路由程序。每个消息都有一个路由键（ routing key ），就是一个简单的字符串。交换机中有一系列的绑定（ binding），即路由规则（ routes ）。交换机可以有多个。多个队列可以和同一个交换机绑定，同时多个交换机也可以和同一个队列绑定。（多对多的关系）三种交换机：
	1.   Fanout Exchange （不处理路由键）：一个发送到交换机上的消息都会被转发到与该交换机绑定的所有队列上。 Fanout 交换机发消息是最快的。
	2.   Direct Exchange （处理路由键）：如果一个队列绑定到该交换机上，并且当前要求路由键为 X ，只有路由键是 X 的消息才会被这个队列转发。
	3.   Topic Exchange （将路由键和某模式进行匹配，可以理解成模糊处理）：路由键的词由 “.” 隔开，符号 “#” 表示匹配 0 个或多个词，符号 “\*” 表示匹配不多不少一个词。因此 “  audit.#  ” 能够匹配到 “  audit.irs.corporate  ” ，但是 “  audit.*  ” 只会匹配到 “  audit.irs  ”

- ==持久化==：队列和交换机有一个创建时候指定的标志durable，直译叫做坚固的。durable的唯一含义就是具有这个标志的队列和交换机会在重启之后重新建立，它不表示说在队列当中的消息会在重启后恢复。那么如何才能做到不只是队列和交换机，还有消息都是持久的呢？当你将消息发布到交换机的时候，可以指定一个标志“Delivery Mode”（投递模式）。根据你使用的AMQP的库不同，指定这个标志的方法可能不太一样。简单的说，就是将 Delivery Mode设置成2，也就是持久的即可。一般的AMQP库都是将Delivery Mode设置成1，也就是非持久的。所以要持久化消息的步骤如下：
	1.   将交换机设成 durable 。
	2.   将队列设成 durable 。
	3.   将消息的 Delivery Mode 设置成 2 。绑定（ Bindings ）如何持久化？我们无法在创建绑定的时候设置成 durable 。没问题，如果绑定了一个 durable 的队列和一个 durable 的交换机， RabbitMQ 会自动保留这个绑定。类似的，如果删除了某个队列或交换机（无论是不是 durable ），依赖它的绑定都会自动删除。
	
> 但是首先一个问题是，你真的需要消息是持久的吗？对于一个需要在重启之后回复的消息来说，它需要被写入到磁盘上，而即使是最简单的磁盘操作也是要消耗时间的。如果和消息的内容相比，你更看重的是消息处理的速度，那么不要使用持久化的消息。
> 另外再注意两点：
	1.   RabbitMQ 不允许绑定一个非坚固（ non-durable ）的交换机和一个 durable 的队列。反之亦然。要想成功必须队列和交换机都是 durable 的。
	2.   一旦创建了队列和交换机，就不能修改其标志了。例如，如果创建了一个 non-durable 的队列，然后想把它改变成 durable 的，唯一的办法就是删除这个队列然后重现创建。因此，最好仔细检查创建的标志。

----------------

### 消息队列（MQ）使用过程

**概念说明：**
1.  Broker：简单来说就是消息队列服务器实体。
2.  Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。
3.  Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
4.  Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。
5.  Routing Key：路由关键字，exchange根据这个关键字进行消息投递。
6.  vhost：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。
7.  producer：消息生产者，就是投递消息的程序。
8.  consumer：消息消费者，就是接受消息的程序。
9.  channel：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。

**消息队列的使用过程大概如下：**
1.  客户端连接到消息队列服务器，打开一个channel。
2.  客户端声明一个exchange，并设置相关属性。
3.  客户端声明一个queue，并设置相关属性。
4.  客户端使用routing key，在exchange和queue之间建立好绑定关系。
5.  客户端投递消息到exchange。
6.  exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里。

-----------

### RabbitMQ的优点（适用范围）
1.  基于erlang语言开发具有高可用高并发的优点，适合集群服务器。
2.  健壮、稳定、易用、跨平台、支持多种语言、文档齐全。
3.  有消息确认机制和持久化机制，可靠性高。
4.  开源

-----------------

### RabbitMQ集群配置

rabbitMQ集群配置rabbitMQ是用erlang开发的，集群非常方便，因为erlang天生就是一门分布式语言,但其本身并不支持负载均衡。

**配置的大概步骤:**

1.  修改hostname
``` shell
vim /etc/hostname 	# 添加新的hostname
vim /etc/hosts		# 将新的hostname指向 127.0.1.1
```
2.  rabbitmq的集群依赖于erlang的集群,需要配置相同的magic cookie来实现
``` shell
/var/lib/rabbitMQ/.erlang.cookie
# 权限是400切记 再几个节点之间需要设置相同的文件cookie
```
3.  使用detached参数独立运行,然后再执行集群连接
``` shell
rabbitmqctl stop
rabbitMQ-server -detached
rabbitmqctl stop_arpp
rabbitmqctl reset
rabbitmqctl cluster user@hostname user2@hostname2
rabbitmqctl start_app
```
4.  查看集群状态
``` shell
rabbitmqctl cluster_status
```
> 这样rabbitMQ集群就正常工作了,这种模式更适合非持久化队列，只有该队列是非持久的，客户端才能重新连接到集群里的其他节点，并重新创建队列。假如该队列是持久化的，那么唯一办法是将故障节点恢复起来。
为什么rabbitMQ不将队列复制到集群里每个节点呢？这与它的集群的设计本意相冲突，集群的设计目的就是增加更多节点时，能线性的增加性能（CPU、内存）和容量（内存、磁盘）。

**rabbit模式大概分为以下三种：**
- 单一模式：最简单的情况，非集群模式。没什么好说的。
- 普通模式：默认的集群模式。对于Queue来说，消息实体只存在于其中一个节点，A、B两个节点仅有相同的元数据，即队列结构。当消息进入A节点的Queue中后，consumer从B节点拉取时，rabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连A或B，出口总在A，会产生瓶颈。该模式存在一个问题就是当A节点故障后，B节点无法取到A节点中还未消费的消息实体。如果做了消息持久化，那么得等A节点恢复，然后才可被消费；如果没有持久化的话，然后就没有然后了……
- 镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于rabbitMQ的HA方案。该模式解决了上述问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在consumer取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用(后面会详细介绍这种模式，目前我们搭建的环境属于该模式)了解集群中的基本概念：rabbitMQ的集群节点包括内存节点、磁盘节点。顾名思义内存节点就是将所有数据放在内存，磁盘节点将数据放在磁盘。不过，如前文所述，如果在投递消息时，打开了消息的持久化，那么即使是内存节点，数据还是安全的放在磁盘。一个rabbitMQ集 群中可以共享 user，vhost，queue，exchange等，所有的数据和状态都是必须在所有节点上复制的，一个例外是，那些当前只属于创建它的节点的消息队列，尽管它们可见且可被所有节点读取。rabbitMQ节点可以动态的加入到集群中，一个节点它可以加入到集群中，也可以从集群环集群会进行一个基本的负载均衡。

**集群中有两种节点：**
- 内存节点：只保存状态到内存（一个例外的情况是：持久的queue的持久内容将被保存到disk）
- 磁盘节点：保存状态到内存和磁盘。内存节点虽然不写入磁盘，但是它执行比磁盘节点要好。集群中，只需要一个磁盘节点来保存状态 就足够了 如果集群中只有内存节点，那么不能停止它们，否则所有的状态，消息等都会丢失。

> 如果你 的 rabbitMQ broker 只是由单独一个 node 构成，那么该 node 的失效将导致整个服务临时性的不可用，并且可能会导致 message 丢失（尤其是在非持久化 message 存储于非持久化的 queue 中的时候）。你当然可以将所有 publish 的 message 都设置为持久化的，并且使用持久化的 queue ，但是你仍然无法避免 由于 buffering 导致的问题：因为在 message 被发出后和被 写入磁盘并 fsync 之间存在一个虽然短暂但是会产生问题的时间窗。通过 [publisher confirms] 机制能够确保客户端知道哪些消息已经写入磁盘，尽管如此，你一定仍不希望遇到因为单点故障导致的服务器停用，进而导致服务不可用的尴尬局面，同样，你也一定不喜欢将每一条 message 都写入磁盘导致的服务器性能退化。

----------------
